{% extends "base.html" %}
{% block content %}
  <style>
    .recipe-page .card {
      padding: 14px;
      margin-bottom: 12px;
    }
    .recipe-hero-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      flex-wrap: wrap;
    }
    .recipe-hero-title {
      font-size: 1.8rem;
      font-weight: 800;
      line-height: 1.15;
      margin: 0;
    }
    .recipe-day-nav {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }
    .recipe-day-nav a,
    .recipe-day-nav span {
      padding: 7px 11px;
      border: 1px solid #d7dee7;
      border-radius: 8px;
      text-decoration: none;
      background: #fff;
      color: #17212b;
      font-size: 0.92rem;
      white-space: nowrap;
    }
    .recipe-day-nav span {
      color: #98a2b3;
    }
    .recipe-builder-panel {
      border: 1px solid #d7dee7;
      border-radius: 10px;
      background: #f9fcff;
      padding: 10px;
      margin-top: 10px;
    }
    .entry-method-card {
      margin-top: 10px;
      border: 1px solid #cfe3ff;
      border-radius: 10px;
      background: #f9fcff;
      padding: 10px;
    }
    .entry-method-tabs {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-top: 6px;
    }
    .entry-method-btn {
      padding: 7px 11px;
      border-radius: 8px;
      border: 1px solid #d7dee7;
      background: #fff;
      color: #17212b;
      font-size: 0.92rem;
      cursor: pointer;
    }
    .entry-method-btn.active {
      border-color: #0f766e;
      background: #0f766e;
      color: #fff;
    }
    .entry-method-hint {
      margin: 8px 0 0;
      font-size: 0.92rem;
      color: var(--muted);
    }
    .mim-assist-panel {
      margin-top: 8px;
      border: 1px solid #cfe3ff;
      background: #f9fcff;
      border-radius: 8px;
      padding: 8px;
    }
    .mim-assist-row {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }
    .mim-assist-row input {
      flex: 1 1 260px;
    }
    .mim-note {
      margin: 7px 0 0;
      font-size: 0.9rem;
      line-height: 1.35;
    }
    .recipe-row {
      display: grid;
      grid-template-columns: 1.5fr 0.5fr 0.6fr auto;
      gap: 8px;
      align-items: end;
      margin-bottom: 8px;
    }
    .recipe-row .remove-btn {
      border: 1px solid #d7dee7;
      background: #fff;
      color: #17212b;
      padding: 8px 10px;
    }
    .recipe-actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-top: 8px;
      align-items: center;
    }
    .recipe-actions .secondary {
      border: 1px solid #d7dee7;
      background: #fff;
      color: #17212b;
    }
    .calc-loading {
      display: none;
      align-items: center;
      gap: 8px;
      color: var(--muted);
      font-size: 0.92rem;
    }
    .inline-spinner {
      width: 14px;
      height: 14px;
      border: 2px solid #d7dee7;
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: recipe-spin 0.7s linear infinite;
      flex-shrink: 0;
    }
    @keyframes recipe-spin {
      to {
        transform: rotate(360deg);
      }
    }
    .recipe-status {
      margin: 8px 0 0;
      font-size: 0.92rem;
    }
    .match-table-wrap {
      overflow-x: auto;
      margin-top: 10px;
    }
    .match-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.9rem;
      min-width: 620px;
    }
    .match-table th,
    .match-table td {
      border-bottom: 1px solid #e8edf4;
      padding: 6px;
      text-align: left;
      vertical-align: top;
    }
    .match-table .align-right {
      text-align: right;
    }
    .match-table .align-center {
      text-align: center;
    }
    .match-actions {
      display: inline-flex;
      gap: 6px;
      justify-content: center;
      align-items: center;
      flex-wrap: wrap;
    }
    .match-actions button {
      border: 1px solid #d7dee7;
      background: #fff;
      color: #17212b;
      padding: 4px 8px;
      font-size: 0.82rem;
    }
    .match-editor-cell {
      background: #f9fcff;
      padding: 8px 10px;
    }
    .match-editor-grid {
      display: grid;
      grid-template-columns: 1.2fr auto;
      gap: 8px;
      align-items: end;
      margin-bottom: 8px;
    }
    .match-editor-grid label {
      margin: 0 0 4px;
      font-size: 0.8rem;
      font-weight: 600;
    }
    .match-editor-grid input,
    .match-editor-grid select {
      width: 100%;
    }
    .match-editor-results {
      display: grid;
      grid-template-columns: 1fr auto auto;
      gap: 8px;
      align-items: end;
    }
    .match-editor-msg {
      margin-top: 6px;
      font-size: 0.82rem;
      color: var(--muted);
    }
    .entry-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.9rem;
    }
    .entry-table th,
    .entry-table td {
      border-bottom: 1px solid #e8edf4;
      padding: 7px;
    }
    .entry-table .align-right {
      text-align: right;
    }
    .entry-actions {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      justify-content: flex-end;
      flex-wrap: wrap;
    }
    .entry-actions a {
      color: #175cd3;
      text-decoration: underline;
    }
    .entry-actions form {
      margin: 0;
    }
    .entry-actions button {
      border: none;
      background: transparent;
      color: #b42318;
      text-decoration: underline;
      padding: 0;
      font-size: 0.9rem;
    }
    @media (max-width: 760px) {
      .recipe-hero-title {
        font-size: 1.45rem;
      }
      .recipe-row {
        grid-template-columns: 1fr;
      }
      .match-table {
        min-width: 0;
      }
      .entry-table {
        min-width: 580px;
      }
    }
  </style>

  <div class="recipe-page">
    <div class="card">
      <div class="recipe-hero-row">
        <h1 class="recipe-hero-title">{{ selected_day_weekday }}, {{ selected_day_pretty }}</h1>
        <div class="recipe-day-nav">
          <a href="{{ url_for('main.recipe_calculator_page', day=prev_day, type=entry_type) }}">&lt; Prev</a>
          {% if can_go_next %}
            <a href="{{ url_for('main.recipe_calculator_page', day=next_day, type=entry_type) }}">Next &gt;</a>
          {% else %}
            <span>Next &gt;</span>
          {% endif %}
          <a href="{{ url_for('main.recipe_calculator_page', day=local_today, type=entry_type) }}">Today</a>
        </div>
      </div>
      <p class="muted">Recipe Calculator builds nutrition from ingredient lists, then logs to this day.</p>
    </div>

    <div class="card">
      <h2>Recipe Nutrition Calculator</h2>
      <p class="muted">
        Add full-batch ingredients, press <strong>MIM Calculate</strong>, then set batch yield and servings eaten.
        CoachMIM logs only your eaten portion.
      </p>

      <form id="recipe_form" method="post" action="{{ url_for('main.recipe_calculator_save') }}">
        <input type="hidden" name="day" value="{{ selected_day }}" />
        <input type="hidden" name="ingredients_json" id="recipe_ingredients_json" value="[]" />

        <div class="grid">
          <div>
            <label for="recipe_entry_type">Entry Type</label>
            <select id="recipe_entry_type" name="entry_type">
              <option value="meal" {% if entry_type == "meal" %}selected{% endif %}>Food / Meal</option>
              <option value="drink" {% if entry_type == "drink" %}selected{% endif %}>Drink</option>
            </select>
          </div>
          <div>
            <label for="recipe_eaten_at">Time</label>
            <input id="recipe_eaten_at" name="eaten_at" type="datetime-local" value="{{ default_eaten_at }}" required />
          </div>
          <div>
            <label for="recipe_favorite_id">Quick Favorite</label>
            <select id="recipe_favorite_id">
              <option value="">Choose a favorite</option>
              {% for favorite in meal_favorites %}
                <option
                  data-entry-type="meal"
                  data-description="{{ favorite.description }}"
                  data-label="{{ favorite.label }}"
                  data-portion-notes="{{ favorite.portion_notes }}"
                  data-calories="{{ favorite.calories }}"
                  data-protein-g="{{ favorite.protein_g }}"
                  data-carbs-g="{{ favorite.carbs_g }}"
                  data-fat-g="{{ favorite.fat_g }}"
                  data-sugar-g="{{ favorite.sugar_g }}"
                  data-sodium-mg="{{ favorite.sodium_mg }}"
                  data-caffeine-mg="{{ favorite.caffeine_mg }}"
                >{{ favorite.name }}</option>
              {% endfor %}
              {% for favorite in drink_favorites %}
                <option
                  data-entry-type="drink"
                  data-description="{{ favorite.description }}"
                  data-label="{{ favorite.label }}"
                  data-portion-notes="{{ favorite.portion_notes }}"
                  data-calories="{{ favorite.calories }}"
                  data-protein-g="{{ favorite.protein_g }}"
                  data-carbs-g="{{ favorite.carbs_g }}"
                  data-fat-g="{{ favorite.fat_g }}"
                  data-sugar-g="{{ favorite.sugar_g }}"
                  data-sodium-mg="{{ favorite.sodium_mg }}"
                  data-caffeine-mg="{{ favorite.caffeine_mg }}"
                >{{ favorite.name }}</option>
              {% endfor %}
            </select>
          </div>
          <div>
            <label for="recipe_description">Recipe Name</label>
            <input id="recipe_description" name="description" placeholder="e.g., Electrolyte lemon water" required />
          </div>
          <div>
            <label for="recipe_label">Label</label>
            <input id="recipe_label" name="label" placeholder="Breakfast / Snack / Drink" />
          </div>
          <div>
            <label for="recipe_portion_notes">Portion Notes</label>
            <input id="recipe_portion_notes" name="portion_notes" placeholder="1 serving, 20 oz, etc." />
          </div>
          <div>
            <label for="recipe_batch_yield">Batch Yield (servings)</label>
            <input id="recipe_batch_yield" name="batch_yield" type="number" min="0.1" step="0.1" value="1" required />
          </div>
          <div>
            <label for="recipe_servings_eaten">Servings Eaten (this entry)</label>
            <input id="recipe_servings_eaten" name="servings_eaten" type="number" min="0.1" step="0.1" value="1" required />
          </div>
        </div>

        <div class="entry-method-card">
          <label>Entry Method</label>
          <div class="entry-method-tabs">
            <button id="recipe_method_mim_btn" class="entry-method-btn" type="button">MIM Estimate</button>
            <button id="recipe_method_manual_btn" class="entry-method-btn" type="button">Manual Calculator</button>
          </div>
          <p id="recipe_method_hint" class="entry-method-hint"></p>
        </div>

        <div id="recipe_mim_panel" class="mim-assist-panel">
          <div class="mim-assist-row">
            <input id="recipe_mim_prompt" type="text" placeholder="Describe your meal/drink and serving size (example: 2 cups bowtie pasta with garlic vodka sauce)" />
            <button id="recipe_mim_run" type="button">Ask MIM</button>
          </div>
          <div id="recipe_mim_loading" class="loading-row" style="display: none; margin-top: 8px;">
            <span class="inline-spinner"></span>
            <span>MIM is estimating this entry...</span>
          </div>
          <p id="recipe_mim_status" class="mim-note muted"></p>
        </div>

        <div id="recipe_manual_panel">
          <div class="recipe-builder-panel">
            <label>Ingredients</label>
            <div id="recipe_rows"></div>
            <div class="recipe-actions">
              <button class="secondary" type="button" id="recipe_add_row">+ Add Ingredient</button>
              <button type="button" id="recipe_calculate">MIM Calculate</button>
              <div id="recipe_loading" class="calc-loading">
                <span class="inline-spinner"></span>
                <span>MIM is calculating nutrition...</span>
              </div>
            </div>
            <p id="recipe_status" class="recipe-status muted"></p>

            <div class="match-table-wrap">
              <table class="match-table">
                <thead>
                  <tr>
                    <th>Ingredient</th>
                    <th>Matched Catalog Item</th>
                    <th class="align-right">Cal</th>
                    <th class="align-right">P/C/F</th>
                    <th class="align-right">Sugar</th>
                    <th class="align-center">Action</th>
                  </tr>
                </thead>
                <tbody id="recipe_match_rows">
                  <tr>
                    <td colspan="6" class="muted">No calculation yet.</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
        </div>

        <h3 style="margin-top: 12px; margin-bottom: 6px;">Batch Totals</h3>
        <div class="grid" style="margin-top: 8px;">
          <div>
            <label for="recipe_calories">Batch Calories</label>
            <input id="recipe_calories" name="calories" type="number" min="0" />
          </div>
          <div>
            <label for="recipe_protein_g">Batch Protein (g)</label>
            <input id="recipe_protein_g" name="protein_g" type="number" min="0" step="0.1" />
          </div>
          <div>
            <label for="recipe_carbs_g">Batch Carbs (g)</label>
            <input id="recipe_carbs_g" name="carbs_g" type="number" min="0" step="0.1" />
          </div>
          <div>
            <label for="recipe_fat_g">Batch Fat (g)</label>
            <input id="recipe_fat_g" name="fat_g" type="number" min="0" step="0.1" />
          </div>
          <div>
            <label for="recipe_sugar_g">Batch Sugar (g)</label>
            <input id="recipe_sugar_g" name="sugar_g" type="number" min="0" step="0.1" />
          </div>
          <div>
            <label for="recipe_sodium_mg">Batch Sodium (mg)</label>
            <input id="recipe_sodium_mg" name="sodium_mg" type="number" min="0" step="0.1" />
          </div>
          <div>
            <label for="recipe_caffeine_mg">Batch Caffeine (mg)</label>
            <input id="recipe_caffeine_mg" name="caffeine_mg" type="number" min="0" step="0.1" />
          </div>
        </div>

        <h3 style="margin-top: 12px; margin-bottom: 6px;">Your Intake (auto-calculated)</h3>
        <p id="recipe_intake_hint" class="muted" style="margin-top: 0;">Logging 1 of 1 servings (100%).</p>
        <div class="grid" style="margin-top: 8px;">
          <div>
            <label for="recipe_intake_calories">Logged Calories</label>
            <input id="recipe_intake_calories" type="text" readonly />
          </div>
          <div>
            <label for="recipe_intake_protein_g">Logged Protein (g)</label>
            <input id="recipe_intake_protein_g" type="text" readonly />
          </div>
          <div>
            <label for="recipe_intake_carbs_g">Logged Carbs (g)</label>
            <input id="recipe_intake_carbs_g" type="text" readonly />
          </div>
          <div>
            <label for="recipe_intake_fat_g">Logged Fat (g)</label>
            <input id="recipe_intake_fat_g" type="text" readonly />
          </div>
          <div>
            <label for="recipe_intake_sugar_g">Logged Sugar (g)</label>
            <input id="recipe_intake_sugar_g" type="text" readonly />
          </div>
          <div>
            <label for="recipe_intake_sodium_mg">Logged Sodium (mg)</label>
            <input id="recipe_intake_sodium_mg" type="text" readonly />
          </div>
          <div>
            <label for="recipe_intake_caffeine_mg">Logged Caffeine (mg)</label>
            <input id="recipe_intake_caffeine_mg" type="text" readonly />
          </div>
        </div>

        <div class="grid" style="margin-top: 8px;">
          <div>
            <label for="recipe_save_favorite">Favorite</label>
            <label style="font-weight: 500; margin-bottom: 0;">
              <input id="recipe_save_favorite" name="save_favorite" type="checkbox" />
              Save this as favorite
            </label>
          </div>
          <div>
            <label for="recipe_favorite_name">Favorite Name (optional)</label>
            <input id="recipe_favorite_name" name="favorite_name" placeholder="e.g., morning lemon water" />
          </div>
        </div>

        <div class="recipe-actions" style="margin-top: 12px;">
          <button type="submit">Save Recipe Entry</button>
        </div>
      </form>
    </div>

    <div class="card">
      <h2>Entries For {{ selected_day }}</h2>
      {% if day_entries %}
        <div style="overflow-x: auto;">
          <table class="entry-table">
            <thead>
              <tr>
                <th>Time</th>
                <th>Type</th>
                <th>Item</th>
                <th>Portion</th>
                <th class="align-right">Calories</th>
                <th class="align-right">P/C/F</th>
                <th class="align-right">Actions</th>
              </tr>
            </thead>
            <tbody>
              {% for meal in day_entries %}
                <tr>
                  <td>{{ meal.eaten_at.strftime("%H:%M") }}</td>
                  <td>{{ "Drink" if meal.is_beverage else "Food" }}</td>
                  <td>{{ meal.description or (meal.food_item.display_name() if meal.food_item else "Entry") }}</td>
                  <td>{{ meal.portion_notes or "n/a" }}</td>
                  <td class="align-right">{{ meal.calories if meal.calories is not none else "-" }}</td>
                  <td class="align-right">
                    {{ meal.protein_g if meal.protein_g is not none else "-" }}/{{ meal.carbs_g if meal.carbs_g is not none else "-" }}/{{ meal.fat_g if meal.fat_g is not none else "-" }}
                  </td>
                  <td class="align-right">
                    <div class="entry-actions">
                      <a href="{{ url_for('main.checkin_form', day=selected_day, view='drink' if meal.is_beverage else 'meal', edit_drink_id=meal.id if meal.is_beverage else None, edit_meal_id=meal.id if not meal.is_beverage else None) }}">Edit</a>
                      <form
                        method="post"
                        action="{{ url_for('main.checkin_meal_quick_delete', meal_id=meal.id) }}"
                        onsubmit="return confirm('Delete this entry?');"
                      >
                        <input type="hidden" name="day" value="{{ selected_day }}" />
                        <input type="hidden" name="view" value="{{ 'drink' if meal.is_beverage else 'meal' }}" />
                        <button type="submit">Delete</button>
                      </form>
                    </div>
                  </td>
                </tr>
              {% endfor %}
            </tbody>
          </table>
        </div>
      {% else %}
        <p class="muted">No food/drink entries for this day yet.</p>
      {% endif %}
    </div>
  </div>

  <script>
    (function () {
      const unitOptions = ["serving", "g", "oz", "lb", "ml", "cup", "tbsp", "tsp", "item"];
      const rowsHost = document.getElementById("recipe_rows");
      const addButton = document.getElementById("recipe_add_row");
      const calcButton = document.getElementById("recipe_calculate");
      const loadingEl = document.getElementById("recipe_loading");
      const statusEl = document.getElementById("recipe_status");
      const matchRowsEl = document.getElementById("recipe_match_rows");
      const ingredientsHidden = document.getElementById("recipe_ingredients_json");
      const entryTypeField = document.getElementById("recipe_entry_type");
      const favoriteSelect = document.getElementById("recipe_favorite_id");
      const recipeMethodMimButton = document.getElementById("recipe_method_mim_btn");
      const recipeMethodManualButton = document.getElementById("recipe_method_manual_btn");
      const recipeMethodHint = document.getElementById("recipe_method_hint");
      const recipeMimPanel = document.getElementById("recipe_mim_panel");
      const recipeManualPanel = document.getElementById("recipe_manual_panel");
      const recipeMimPrompt = document.getElementById("recipe_mim_prompt");
      const recipeMimRunButton = document.getElementById("recipe_mim_run");
      const recipeMimLoading = document.getElementById("recipe_mim_loading");
      const recipeMimStatus = document.getElementById("recipe_mim_status");
      const batchYieldField = document.getElementById("recipe_batch_yield");
      const servingsEatenField = document.getElementById("recipe_servings_eaten");
      const intakeHintEl = document.getElementById("recipe_intake_hint");
      const mimAssistEndpoint = "{{ url_for('main.ai_day_manager_assist') }}";
      let latestMatchRows = [];

      const fieldMap = {
        description: document.getElementById("recipe_description"),
        label: document.getElementById("recipe_label"),
        portion_notes: document.getElementById("recipe_portion_notes"),
        calories: document.getElementById("recipe_calories"),
        protein_g: document.getElementById("recipe_protein_g"),
        carbs_g: document.getElementById("recipe_carbs_g"),
        fat_g: document.getElementById("recipe_fat_g"),
        sugar_g: document.getElementById("recipe_sugar_g"),
        sodium_mg: document.getElementById("recipe_sodium_mg"),
        caffeine_mg: document.getElementById("recipe_caffeine_mg"),
        favorite_name: document.getElementById("recipe_favorite_name")
      };
      const intakeFieldMap = {
        calories: document.getElementById("recipe_intake_calories"),
        protein_g: document.getElementById("recipe_intake_protein_g"),
        carbs_g: document.getElementById("recipe_intake_carbs_g"),
        fat_g: document.getElementById("recipe_intake_fat_g"),
        sugar_g: document.getElementById("recipe_intake_sugar_g"),
        sodium_mg: document.getElementById("recipe_intake_sodium_mg"),
        caffeine_mg: document.getElementById("recipe_intake_caffeine_mg")
      };

      function normalizeText(value) {
        return String(value || "").replace(/\s+/g, " ").trim();
      }

      async function parseJsonResponseSafe(response, fallbackMessage) {
        const rawText = await response.text();
        let data = null;
        try {
          data = rawText ? JSON.parse(rawText) : null;
        } catch (error) {
          data = null;
        }

        if (data && typeof data === "object") {
          return data;
        }

        const redirectedToLogin = response.redirected && response.url && response.url.includes("/login");
        if (redirectedToLogin || response.status === 401) {
          throw new Error("Your session expired. Please log in again and retry.");
        }
        if (response.status === 409) {
          throw new Error("Complete your core profile first, then retry this action.");
        }
        if (rawText && /<!doctype html/i.test(rawText)) {
          throw new Error(
            fallbackMessage || "Server returned an unexpected page. Refresh and try again."
          );
        }
        throw new Error(fallbackMessage || `Request failed (${response.status}).`);
      }

      function setRecipeMethod(mode) {
        const activeMode = mode === "manual" ? "manual" : "mim";
        recipeMethodMimButton?.classList.toggle("active", activeMode === "mim");
        recipeMethodManualButton?.classList.toggle("active", activeMode === "manual");
        if (recipeMimPanel) {
          recipeMimPanel.style.display = activeMode === "mim" ? "" : "none";
        }
        if (recipeManualPanel) {
          recipeManualPanel.style.display = activeMode === "manual" ? "" : "none";
        }
        if (recipeMethodHint) {
          recipeMethodHint.textContent =
            activeMode === "mim"
              ? "Describe once. MIM estimates calories/macros quickly, then you can review and save."
              : "Add ingredient rows and calculate for precise manual totals.";
        }
        if (activeMode === "mim" && recipeMimPrompt && !normalizeText(recipeMimPrompt.value)) {
          recipeMimPrompt.value = normalizeText(fieldMap.description?.value || "");
        }
      }

      function buildUnitOptions(selected) {
        return unitOptions
          .map((unit) => `<option value="${unit}" ${unit === selected ? "selected" : ""}>${unit}</option>`)
          .join("");
      }

      function createRow(data = {}) {
        const row = document.createElement("div");
        row.className = "recipe-row";
        row.innerHTML = `
          <div>
            <label>Ingredient</label>
            <input type="text" class="ingredient-name" placeholder="e.g., honey" value="${normalizeText(data.name || data.food_name || "")}" />
          </div>
          <div>
            <label>Qty</label>
            <input type="number" min="0" step="0.01" class="ingredient-qty" value="${data.quantity !== undefined && data.quantity !== null ? data.quantity : 1}" />
          </div>
          <div>
            <label>Unit</label>
            <select class="ingredient-unit">${buildUnitOptions(data.unit || "serving")}</select>
          </div>
          <div>
            <label>&nbsp;</label>
            <button type="button" class="remove-btn">Remove</button>
          </div>
        `;
        rowsHost.appendChild(row);
      }

      function collectRows() {
        const rows = [];
        rowsHost.querySelectorAll(".recipe-row").forEach((row) => {
          const name = normalizeText(row.querySelector(".ingredient-name")?.value);
          const qtyRaw = row.querySelector(".ingredient-qty")?.value;
          const qty = Number(qtyRaw);
          const unit = normalizeText(row.querySelector(".ingredient-unit")?.value) || "serving";
          if (!name) return;
          rows.push({
            name,
            quantity: Number.isFinite(qty) && qty > 0 ? qty : 1,
            unit
          });
        });
        return rows;
      }

      function setStatus(message, isError = false) {
        statusEl.textContent = message || "";
        statusEl.style.color = isError ? "#b42318" : "";
      }

      function setLoading(isLoading) {
        loadingEl.style.display = isLoading ? "inline-flex" : "none";
        calcButton.disabled = isLoading;
      }

      function renderMatchRows(rows) {
        if (!Array.isArray(rows) || rows.length === 0) {
          latestMatchRows = [];
          matchRowsEl.innerHTML = '<tr><td colspan="6" class="muted">No calculation rows.</td></tr>';
          return;
        }
        latestMatchRows = rows.map((row) => ({ ...row }));
        matchRowsEl.innerHTML = rows
          .map((row, index) => {
            const sourceName = normalizeText(row.matched_display_name || "");
            const matchedText = sourceName || "No confident match";
            const cal = row.calories !== null && row.calories !== undefined ? Number(row.calories).toFixed(0) : "-";
            const protein = row.protein_g !== null && row.protein_g !== undefined ? Number(row.protein_g).toFixed(1) : "-";
            const carbs = row.carbs_g !== null && row.carbs_g !== undefined ? Number(row.carbs_g).toFixed(1) : "-";
            const fat = row.fat_g !== null && row.fat_g !== undefined ? Number(row.fat_g).toFixed(1) : "-";
            const sugar = row.sugar_g !== null && row.sugar_g !== undefined ? Number(row.sugar_g).toFixed(1) : "-";
            const safeIngredient = normalizeText(row.input_name || row.food_name || "-");
            return `
              <tr>
                <td>${safeIngredient}</td>
                <td>${matchedText}</td>
                <td class="align-right">${cal}</td>
                <td class="align-right">${protein}/${carbs}/${fat}</td>
                <td class="align-right">${sugar}</td>
                <td class="align-center">
                  <div class="match-actions">
                    <button type="button" class="match-edit-toggle" data-row-index="${index}">Find Better</button>
                  </div>
                </td>
              </tr>
              <tr class="match-editor-row" id="match_editor_${index}" style="display:none;">
                <td colspan="6" class="match-editor-cell">
                  <div class="match-editor-grid">
                    <div>
                      <label for="match_query_${index}">Search Match</label>
                      <input id="match_query_${index}" type="text" value="${safeIngredient}" />
                    </div>
                    <button type="button" class="match-search-btn" data-row-index="${index}">Search</button>
                  </div>
                  <div class="match-editor-results">
                    <select id="match_results_${index}">
                      <option value="">Choose a replacement item</option>
                    </select>
                    <button type="button" class="match-apply-btn" data-row-index="${index}">Use Selected</button>
                    <button type="button" class="match-cancel-btn" data-row-index="${index}">Close</button>
                  </div>
                  <div id="match_msg_${index}" class="match-editor-msg">Search local catalog, then choose a better item.</div>
                </td>
              </tr>
            `;
          })
          .join("");
      }

      function numberOrNull(value) {
        if (value === null || value === undefined || value === "") return null;
        const parsed = Number(value);
        return Number.isFinite(parsed) ? parsed : null;
      }

      function displayDecimal(value, digits = 1) {
        const parsed = numberOrNull(value);
        if (parsed === null) return "";
        return parsed.toFixed(digits);
      }

      function displayServing(value) {
        const parsed = numberOrNull(value);
        if (parsed === null || parsed <= 0) return "1";
        const rounded = Math.round(parsed * 100) / 100;
        if (Math.abs(rounded - Math.round(rounded)) < 0.001) {
          return String(Math.round(rounded));
        }
        return rounded.toFixed(2).replace(/0+$/, "").replace(/\.$/, "");
      }

      function recalculateIntakePreview() {
        const batchYieldRaw = numberOrNull(batchYieldField?.value);
        const servingsRaw = numberOrNull(servingsEatenField?.value);
        const batchYield = batchYieldRaw && batchYieldRaw > 0 ? batchYieldRaw : 1;
        const servings = servingsRaw && servingsRaw > 0 ? servingsRaw : 1;
        const ratio = servings / batchYield;

        if (intakeHintEl) {
          intakeHintEl.textContent = `Logging ${displayServing(servings)} of ${displayServing(batchYield)} servings (${Math.round(ratio * 100)}%).`;
        }

        const batchCalories = numberOrNull(fieldMap.calories.value);
        const batchProtein = numberOrNull(fieldMap.protein_g.value);
        const batchCarbs = numberOrNull(fieldMap.carbs_g.value);
        const batchFat = numberOrNull(fieldMap.fat_g.value);
        const batchSugar = numberOrNull(fieldMap.sugar_g.value);
        const batchSodium = numberOrNull(fieldMap.sodium_mg.value);
        const batchCaffeine = numberOrNull(fieldMap.caffeine_mg.value);

        intakeFieldMap.calories.value = batchCalories === null ? "" : String(Math.round(batchCalories * ratio));
        intakeFieldMap.protein_g.value = batchProtein === null ? "" : displayDecimal(batchProtein * ratio, 1);
        intakeFieldMap.carbs_g.value = batchCarbs === null ? "" : displayDecimal(batchCarbs * ratio, 1);
        intakeFieldMap.fat_g.value = batchFat === null ? "" : displayDecimal(batchFat * ratio, 1);
        intakeFieldMap.sugar_g.value = batchSugar === null ? "" : displayDecimal(batchSugar * ratio, 1);
        intakeFieldMap.sodium_mg.value = batchSodium === null ? "" : displayDecimal(batchSodium * ratio, 1);
        intakeFieldMap.caffeine_mg.value = batchCaffeine === null ? "" : displayDecimal(batchCaffeine * ratio, 1);
      }

      function normalizeUnit(unit) {
        const raw = normalizeText(unit).toLowerCase().replace(/\./g, "");
        const map = {
          serving: "serving",
          servings: "serving",
          portion: "serving",
          portions: "serving",
          g: "g",
          gram: "g",
          grams: "g",
          oz: "oz",
          ounce: "oz",
          ounces: "oz",
          lb: "lb",
          lbs: "lb",
          pound: "lb",
          pounds: "lb",
          ml: "ml",
          milliliter: "ml",
          milliliters: "ml",
          cup: "cup",
          cups: "cup",
          tbsp: "tbsp",
          tablespoon: "tbsp",
          tablespoons: "tbsp",
          tsp: "tsp",
          teaspoon: "tsp",
          teaspoons: "tsp",
          item: "item",
          items: "item",
          slice: "item",
          slices: "item",
          piece: "item",
          pieces: "item"
        };
        return map[raw] || "serving";
      }

      function unitToGrams(quantity, unit) {
        const map = { g: 1, oz: 28.349523125, lb: 453.59237 };
        const normalized = normalizeUnit(unit);
        if (!Object.prototype.hasOwnProperty.call(map, normalized)) return null;
        return Number(quantity) * map[normalized];
      }

      function unitToMl(quantity, unit) {
        const map = { ml: 1, cup: 240, tbsp: 15, tsp: 5, oz: 29.5735 };
        const normalized = normalizeUnit(unit);
        if (!Object.prototype.hasOwnProperty.call(map, normalized)) return null;
        return Number(quantity) * map[normalized];
      }

      function calculateFactor(quantity, unit, servingSize, servingUnit) {
        const qty = Number(quantity);
        let safeQty = Number.isFinite(qty) && qty > 0 ? qty : 1;
        const chosenUnit = normalizeUnit(unit);
        if (chosenUnit === "serving") return safeQty;

        const baseSize = Number(servingSize);
        const baseUnit = normalizeUnit(servingUnit);
        if (!Number.isFinite(baseSize) || baseSize <= 0) {
          return chosenUnit === "item" ? safeQty : 1;
        }

        if (chosenUnit === baseUnit) return safeQty / baseSize;

        const qtyGrams = unitToGrams(safeQty, chosenUnit);
        const servingGrams = unitToGrams(baseSize, baseUnit);
        if (qtyGrams !== null && servingGrams !== null && servingGrams > 0) {
          return qtyGrams / servingGrams;
        }

        const qtyMl = unitToMl(safeQty, chosenUnit);
        const servingMl = unitToMl(baseSize, baseUnit);
        if (qtyMl !== null && servingMl !== null && servingMl > 0) {
          return qtyMl / servingMl;
        }

        if (chosenUnit === "item" && baseUnit === "item") return safeQty / baseSize;
        if (chosenUnit === "item") return safeQty;
        return 1;
      }

      function updateTotalsFromRows() {
        const entryRows = collectRows();
        const totals = {
          calories: 0,
          protein_g: 0,
          carbs_g: 0,
          fat_g: 0,
          sugar_g: 0,
          sodium_mg: 0,
          caffeine_mg: 0
        };

        latestMatchRows = latestMatchRows.map((row, index) => {
          const ingredientRow = entryRows[index] || {};
          const quantity = ingredientRow.quantity ?? row.quantity ?? 1;
          const unit = ingredientRow.unit || row.unit || "serving";
          const factor = calculateFactor(quantity, unit, row.serving_size, row.serving_unit);

          const calories = (numberOrNull(row.base_calories) ?? numberOrNull(row.calories) ?? 0) * factor;
          const protein = (numberOrNull(row.base_protein_g) ?? numberOrNull(row.protein_g) ?? 0) * factor;
          const carbs = (numberOrNull(row.base_carbs_g) ?? numberOrNull(row.carbs_g) ?? 0) * factor;
          const fat = (numberOrNull(row.base_fat_g) ?? numberOrNull(row.fat_g) ?? 0) * factor;
          const sugar = (numberOrNull(row.base_sugar_g) ?? numberOrNull(row.sugar_g) ?? 0) * factor;
          const sodium = (numberOrNull(row.base_sodium_mg) ?? numberOrNull(row.sodium_mg) ?? 0) * factor;
          const caffeine = (numberOrNull(row.base_caffeine_mg) ?? numberOrNull(row.caffeine_mg) ?? 0) * factor;

          totals.calories += calories;
          totals.protein_g += protein;
          totals.carbs_g += carbs;
          totals.fat_g += fat;
          totals.sugar_g += sugar;
          totals.sodium_mg += sodium;
          totals.caffeine_mg += caffeine;

          return {
            ...row,
            quantity,
            unit,
            calories: Math.round(calories * 10) / 10,
            protein_g: Math.round(protein * 100) / 100,
            carbs_g: Math.round(carbs * 100) / 100,
            fat_g: Math.round(fat * 100) / 100,
            sugar_g: Math.round(sugar * 100) / 100,
            sodium_mg: Math.round(sodium * 100) / 100,
            caffeine_mg: Math.round(caffeine * 100) / 100
          };
        });

        applyTotals({
          calories: totals.calories > 0 ? Math.round(totals.calories) : 0,
          protein_g: Math.round(totals.protein_g * 10) / 10,
          carbs_g: Math.round(totals.carbs_g * 10) / 10,
          fat_g: Math.round(totals.fat_g * 10) / 10,
          sugar_g: Math.round(totals.sugar_g * 10) / 10,
          sodium_mg: Math.round(totals.sodium_mg * 10) / 10,
          caffeine_mg: Math.round(totals.caffeine_mg * 10) / 10
        });

        renderMatchRows(latestMatchRows);
        ingredientsHidden.value = JSON.stringify(latestMatchRows);
      }

      async function searchReplacementMatches(index) {
        const queryEl = document.getElementById(`match_query_${index}`);
        const selectEl = document.getElementById(`match_results_${index}`);
        const msgEl = document.getElementById(`match_msg_${index}`);
        const query = normalizeText(queryEl?.value);
        if (!query) {
          if (msgEl) msgEl.textContent = "Enter a search term first.";
          return;
        }
        if (msgEl) msgEl.textContent = "Searching catalog...";

        try {
          const response = await fetch(`{{ url_for('main.food_search') }}?q=${encodeURIComponent(query)}`, {
            method: "GET",
            headers: { Accept: "application/json" }
          });
          const data = await parseJsonResponseSafe(response, "Food search failed.");
          const results = Array.isArray(data.results) ? data.results : [];
          const options = results
            .filter((item) => item && item.id)
            .map((item) => {
              const nutrientDefined =
                item.calories !== null ||
                item.protein_g !== null ||
                item.carbs_g !== null ||
                item.fat_g !== null ||
                item.sugar_g !== null ||
                item.sodium_mg !== null ||
                item.caffeine_mg !== null;
              const label = `${item.display_name || item.name || "Food item"} | ${item.calories ?? "?"} kcal`;
              return {
                id: item.id,
                label,
                raw: item,
                nutrientDefined
              };
            });

          selectEl.innerHTML = '<option value="">Choose a replacement item</option>';
          options.forEach((opt) => {
            const option = document.createElement("option");
            option.value = String(opt.id);
            option.textContent = opt.nutrientDefined ? opt.label : `${opt.label} (nutrition missing)`;
            option.dataset.payload = JSON.stringify(opt.raw);
            selectEl.appendChild(option);
          });

          if (msgEl) msgEl.textContent = options.length ? `Found ${options.length} candidate matches.` : "No matches found. Try a broader term.";
        } catch (error) {
          if (msgEl) msgEl.textContent = "Search failed. Please try again.";
        }
      }

      function applyReplacementMatch(index) {
        const selectEl = document.getElementById(`match_results_${index}`);
        const msgEl = document.getElementById(`match_msg_${index}`);
        const selected = selectEl?.options?.[selectEl.selectedIndex];
        if (!selected || !selected.value || !selected.dataset.payload) {
          if (msgEl) msgEl.textContent = "Choose a replacement item first.";
          return;
        }

        let payload;
        try {
          payload = JSON.parse(selected.dataset.payload);
        } catch (error) {
          if (msgEl) msgEl.textContent = "Invalid match payload.";
          return;
        }
        if (!latestMatchRows[index]) return;

        latestMatchRows[index] = {
          ...latestMatchRows[index],
          food_item_id: payload.id ?? null,
          food_name: payload.display_name || payload.name || latestMatchRows[index].food_name,
          matched_display_name: payload.display_name || payload.name || latestMatchRows[index].matched_display_name,
          match_source: payload.source || "local",
          serving_size: numberOrNull(payload.serving_size),
          serving_unit: normalizeText(payload.serving_unit) || null,
          base_calories: numberOrNull(payload.calories),
          base_protein_g: numberOrNull(payload.protein_g),
          base_carbs_g: numberOrNull(payload.carbs_g),
          base_fat_g: numberOrNull(payload.fat_g),
          base_sugar_g: numberOrNull(payload.sugar_g),
          base_sodium_mg: numberOrNull(payload.sodium_mg),
          base_caffeine_mg: numberOrNull(payload.caffeine_mg)
        };

        const editorRow = document.getElementById(`match_editor_${index}`);
        if (editorRow) editorRow.style.display = "none";
        updateTotalsFromRows();
        setStatus(`Updated match for "${latestMatchRows[index].input_name || latestMatchRows[index].food_name}".`);
      }

      function applyTotals(totals) {
        if (!totals || typeof totals !== "object") return;
        Object.keys(totals).forEach((key) => {
          const field = fieldMap[key];
          if (!field) return;
          const value = totals[key];
          field.value = value === null || value === undefined ? "" : String(value);
        });
        recalculateIntakePreview();
      }

      function applySuggestedFields(suggested, force = false) {
        if (!suggested || typeof suggested !== "object") return;
        ["description", "label", "portion_notes"].forEach((key) => {
          const field = fieldMap[key];
          if (!field) return;
          if ((force || !normalizeText(field.value)) && normalizeText(suggested[key])) {
            field.value = String(suggested[key]);
          }
        });
      }

      async function runRecipeMimEstimate() {
        const prompt = normalizeText(recipeMimPrompt?.value) || normalizeText(fieldMap.description?.value);
        if (!prompt) {
          if (recipeMimStatus) {
            recipeMimStatus.textContent = "Describe the meal/drink first (include amount or serving size).";
          }
          recipeMimPrompt?.focus();
          return;
        }

        if (recipeMimLoading) {
          recipeMimLoading.style.display = "";
        }
        if (recipeMimRunButton) {
          recipeMimRunButton.disabled = true;
        }
        if (recipeMimStatus) {
          recipeMimStatus.textContent = "";
        }

        try {
          const context = entryTypeField?.value === "drink" ? "drink" : "meal";
          const response = await fetch(mimAssistEndpoint, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ context, text: prompt })
          });
          const data = await parseJsonResponseSafe(response, "MIM estimate failed.");
          if (!response.ok || !data.ok) {
            throw new Error(data.error || "MIM estimate failed.");
          }

          if (data.reply && recipeMimStatus) {
            recipeMimStatus.textContent = data.reply;
          }
          applySuggestedFields(data.suggested_fields || {}, true);
          applyTotals(data.suggested_fields || {});
          if (fieldMap.description && !normalizeText(fieldMap.description.value)) {
            fieldMap.description.value = prompt;
          }
          if (!normalizeText(fieldMap.favorite_name.value) && normalizeText(fieldMap.description.value)) {
            fieldMap.favorite_name.value = normalizeText(fieldMap.description.value);
          }
          recalculateIntakePreview();
        } catch (error) {
          if (recipeMimStatus) {
            recipeMimStatus.textContent = error.message || "MIM estimate failed.";
          }
        } finally {
          if (recipeMimLoading) {
            recipeMimLoading.style.display = "none";
          }
          if (recipeMimRunButton) {
            recipeMimRunButton.disabled = false;
          }
        }
      }

      async function calculateRecipe() {
        const ingredients = collectRows();
        if (!ingredients.length) {
          setStatus("Add at least one ingredient before calculating.", true);
          return;
        }

        setLoading(true);
        setStatus("Running MIM calculation...");

        try {
          const response = await fetch("{{ url_for('main.recipe_calculator_calculate') }}", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              entry_type: entryTypeField.value,
              title: fieldMap.description.value,
              label: fieldMap.label.value,
              ingredients
            })
          });
          const data = await parseJsonResponseSafe(response, "Recipe calculation failed.");
          if (!response.ok || !data.ok) {
            throw new Error(data.error || "Recipe calculation failed.");
          }

          applyTotals(data.totals || {});
          applySuggestedFields(data.suggested_fields || {});
          const normalizedRows = (Array.isArray(data.ingredients) ? data.ingredients : []).map((row) => ({
            ...row,
            base_calories: numberOrNull(row.calories),
            base_protein_g: numberOrNull(row.protein_g),
            base_carbs_g: numberOrNull(row.carbs_g),
            base_fat_g: numberOrNull(row.fat_g),
            base_sugar_g: numberOrNull(row.sugar_g),
            base_sodium_mg: numberOrNull(row.sodium_mg),
            base_caffeine_mg: numberOrNull(row.caffeine_mg)
          }));
          latestMatchRows = normalizedRows;
          renderMatchRows(normalizedRows);
          ingredientsHidden.value = JSON.stringify(normalizedRows);

          const matched = Number(data.matched_count || 0);
          const total = Number(data.total_count || 0);
          const confidence = Number(data.confidence || 0);
          const unmatched = Array.isArray(data.unmatched) ? data.unmatched.filter(Boolean) : [];
          const baseStatus = `Matched ${matched}/${total} ingredients (confidence ${Math.round(confidence * 100)}%).`;
          const unmatchedStatus = unmatched.length ? ` Unmatched: ${unmatched.slice(0, 5).join(", ")}.` : "";
          setStatus(baseStatus + unmatchedStatus, false);

          if (!normalizeText(fieldMap.favorite_name.value) && normalizeText(fieldMap.description.value)) {
            fieldMap.favorite_name.value = normalizeText(fieldMap.description.value);
          }
        } catch (error) {
          setStatus(error.message || "Recipe calculation failed.", true);
        } finally {
          setLoading(false);
        }
      }

      function refreshFavoriteOptions() {
        const targetType = entryTypeField.value === "drink" ? "drink" : "meal";
        let selectedIsVisible = false;
        Array.from(favoriteSelect.options).forEach((opt, index) => {
          if (index === 0) {
            opt.hidden = false;
            return;
          }
          const rowType = opt.dataset.entryType || "meal";
          const show = rowType === targetType;
          opt.hidden = !show;
          if (show && opt.selected) {
            selectedIsVisible = true;
          }
        });
        if (!selectedIsVisible) {
          favoriteSelect.selectedIndex = 0;
        }
        if (targetType === "drink" && !normalizeText(fieldMap.label.value)) {
          fieldMap.label.value = "Drink";
        }
      }

      function applyFavorite(option) {
        if (!option || !option.value) return;
        fieldMap.description.value = option.dataset.description || option.textContent.trim();
        fieldMap.label.value = option.dataset.label || (entryTypeField.value === "drink" ? "Drink" : "");
        fieldMap.portion_notes.value = option.dataset.portionNotes || option.dataset.portion_notes || "";
        fieldMap.calories.value = option.dataset.calories || "";
        fieldMap.protein_g.value = option.dataset.proteinG || option.dataset.protein_g || "";
        fieldMap.carbs_g.value = option.dataset.carbsG || option.dataset.carbs_g || "";
        fieldMap.fat_g.value = option.dataset.fatG || option.dataset.fat_g || "";
        fieldMap.sugar_g.value = option.dataset.sugarG || option.dataset.sugar_g || "";
        fieldMap.sodium_mg.value = option.dataset.sodiumMg || option.dataset.sodium_mg || "";
        fieldMap.caffeine_mg.value = option.dataset.caffeineMg || option.dataset.caffeine_mg || "";
        if (batchYieldField) batchYieldField.value = "1";
        if (servingsEatenField) servingsEatenField.value = "1";
        if (!normalizeText(fieldMap.favorite_name.value)) {
          fieldMap.favorite_name.value = option.textContent.trim();
        }
        recalculateIntakePreview();
      }

      if (recipeMethodMimButton) {
        recipeMethodMimButton.addEventListener("click", () => setRecipeMethod("mim"));
      }
      if (recipeMethodManualButton) {
        recipeMethodManualButton.addEventListener("click", () => setRecipeMethod("manual"));
      }
      if (recipeMimRunButton) {
        recipeMimRunButton.addEventListener("click", runRecipeMimEstimate);
      }
      if (recipeMimPrompt) {
        recipeMimPrompt.addEventListener("keydown", (event) => {
          if (event.key === "Enter") {
            event.preventDefault();
            runRecipeMimEstimate();
          }
        });
      }

      addButton.addEventListener("click", () => createRow());
      calcButton.addEventListener("click", calculateRecipe);

      rowsHost.addEventListener("click", (event) => {
        const target = event.target;
        if (!(target instanceof HTMLElement)) return;
        if (!target.classList.contains("remove-btn")) return;
        const row = target.closest(".recipe-row");
        if (row) row.remove();
        if (!rowsHost.querySelector(".recipe-row")) {
          createRow();
        }
      });

      rowsHost.addEventListener("change", () => {
        if (latestMatchRows.length) {
          updateTotalsFromRows();
        }
      });

      [fieldMap.calories, fieldMap.protein_g, fieldMap.carbs_g, fieldMap.fat_g, fieldMap.sugar_g, fieldMap.sodium_mg, fieldMap.caffeine_mg]
        .filter(Boolean)
        .forEach((input) => {
          input.addEventListener("input", recalculateIntakePreview);
        });

      if (batchYieldField) {
        batchYieldField.addEventListener("input", recalculateIntakePreview);
        batchYieldField.addEventListener("change", recalculateIntakePreview);
      }
      if (servingsEatenField) {
        servingsEatenField.addEventListener("input", recalculateIntakePreview);
        servingsEatenField.addEventListener("change", recalculateIntakePreview);
      }

      matchRowsEl.addEventListener("click", (event) => {
        const target = event.target;
        if (!(target instanceof HTMLElement)) return;
        const indexValue = target.getAttribute("data-row-index");
        const rowIndex = Number(indexValue);
        if (!Number.isInteger(rowIndex)) return;

        if (target.classList.contains("match-edit-toggle")) {
          const editorRow = document.getElementById(`match_editor_${rowIndex}`);
          if (!editorRow) return;
          const isOpen = editorRow.style.display !== "none";
          matchRowsEl.querySelectorAll(".match-editor-row").forEach((row) => {
            row.style.display = "none";
          });
          editorRow.style.display = isOpen ? "none" : "";
          return;
        }

        if (target.classList.contains("match-search-btn")) {
          searchReplacementMatches(rowIndex);
          return;
        }

        if (target.classList.contains("match-apply-btn")) {
          applyReplacementMatch(rowIndex);
          return;
        }

        if (target.classList.contains("match-cancel-btn")) {
          const editorRow = document.getElementById(`match_editor_${rowIndex}`);
          if (editorRow) editorRow.style.display = "none";
        }
      });

      entryTypeField.addEventListener("change", () => {
        refreshFavoriteOptions();
      });

      favoriteSelect.addEventListener("change", () => {
        const selected = favoriteSelect.options[favoriteSelect.selectedIndex];
        applyFavorite(selected);
      });

      createRow();
      refreshFavoriteOptions();
      setRecipeMethod("mim");
      recalculateIntakePreview();
    })();
  </script>
{% endblock %}
