{% extends "base.html" %}
{% block content %}
  <div class="card">
    <h1>{{ "Edit Meal Entry" if edit_meal else "Log Meal" }}</h1>
    <p class="muted">
      Search common foods, pull defaults, save reusable favorites, and track all entries for the day.
    </p>
    {% if edit_meal %}
      <p><a href="{{ url_for('main.meal_form', day=selected_day) }}">Create a new meal entry instead</a></p>
    {% endif %}
  </div>

  <div class="card">
    <h2>Quick Flow</h2>
    <ol style="margin-top: 0;">
      <li>Start with local search. Use USDA only if local does not match.</li>
      <li>If no match: add custom facts, paste a product link, or parse a nutrition-label photo.</li>
      <li>Add ingredients to the builder, then click <strong>Use Builder Totals</strong>, then <strong>Save Meal</strong>.</li>
    </ol>
  </div>

  <div class="card">
    <form method="get" action="{{ url_for('main.meal_form') }}">
      <div class="grid">
        <div>
          <label for="day">Viewing Day</label>
          <input id="day" name="day" type="date" value="{{ selected_day }}" />
        </div>
      </div>
      <div style="margin-top: 12px;">
        <button type="submit">Load Day</button>
      </div>
    </form>
  </div>

  <div class="card">
    <h2>Daily Intake Snapshot</h2>
    <p class="muted">Selected day: {{ selected_day }}</p>

    <div class="grid">
      <div>
        <div class="muted">Total Calories</div>
        <div class="metric">{{ meal_summary.calories_total }}</div>
      </div>
      <div>
        <div class="muted">Total Carbs (g)</div>
        <div class="metric">{{ meal_summary.carbs_total }}</div>
      </div>
      <div>
        <div class="muted">Total Sugar (g)</div>
        <div class="metric">{{ meal_summary.sugar_total }}</div>
      </div>
      <div>
        <div class="muted">Total Protein (g)</div>
        <div class="metric">{{ meal_summary.protein_total }}</div>
      </div>
      <div>
        <div class="muted">Est. Added Sugar (g)</div>
        <div class="metric">{{ meal_summary.added_sugar_total }}</div>
      </div>
      <div>
        <div class="muted">Est. Natural Sugar (g)</div>
        <div class="metric">{{ meal_summary.natural_sugar_total }}</div>
      </div>
    </div>

    <p class="muted" style="margin-top: 12px;">
      Sugar split is an estimate from food names/tags (used for guidance, not lab-grade nutrition).
    </p>

    <h3 style="margin-top: 16px; margin-bottom: 8px;">MIM Day Summary</h3>
    <ul style="margin-top: 0;">
      {% for note in meal_summary.mim_notes %}
        <li>{{ note }}</li>
      {% endfor %}
    </ul>
  </div>

  <div class="card">
    <form id="meal-form" method="post" action="{{ form_action }}" enctype="multipart/form-data">
      <div class="card" style="margin-bottom: 12px; border-color: #cfe3ff; background: #f9fcff;">
        <label>Add Mode</label>
        <div style="display: flex; gap: 8px; flex-wrap: wrap;">
          <button id="entry_mode_single" type="button">Single Item</button>
          <button id="entry_mode_recipe" type="button" style="background: #fff; color: #17212b; border: 1px solid #d7dee7;">Build Recipe</button>
        </div>
        <p id="entry_mode_hint" class="muted" style="margin: 8px 0 0;">Single Item mode: fastest way to log one food/drink.</p>
      </div>

      <input id="favorite_ingredients" name="favorite_ingredients" type="hidden" />

      <div id="single-entry-panel">
        <div class="grid">
          <div style="grid-column: span 2;">
            <label for="food_search">Food / Drink Search</label>
            <input
              id="food_search"
              placeholder="Type food name (e.g., chicken breast, greek yogurt, coffee)"
              autocomplete="off"
              value="{{ edit_meal.food_item.display_name() if edit_meal and edit_meal.food_item else '' }}"
            />
            <p class="muted" style="margin: 6px 0 0;">Local catalog search first. Click USDA only when local results are not enough.</p>
            <input id="food_item_id" name="food_item_id" type="hidden" value="{{ edit_meal.food_item_id if edit_meal and edit_meal.food_item_id is not none else '' }}" />
            <div id="food-results" style="margin-top: 8px;"></div>
          </div>
          <div>
            <label for="search_usda">&nbsp;</label>
            <button id="search_usda" type="button">Search USDA</button>
          </div>
        </div>
      </div>

      <div id="recipe-entry-panel" class="card" style="margin-top: 12px; margin-bottom: 0; border-color: #cfe3ff; background: #f9fcff;">
        <div style="display: flex; align-items: center; justify-content: space-between; gap: 12px; flex-wrap: wrap;">
          <div>
            <h3 style="margin: 0;">Build a Meal</h3>
            <p class="muted" style="margin: 4px 0 0;">Create a reusable recipe from ingredients and auto-calculate totals.</p>
          </div>
          <button id="builder_toggle" type="button">Build a Meal</button>
        </div>

        <div id="meal-builder-panel" style="display: none; margin-top: 12px;">
          <div style="margin-top: 4px;">
            <label>Ingredient Source</label>
            <div style="display: flex; gap: 8px; flex-wrap: wrap;">
              <button id="builder_source_catalog" type="button">Catalog</button>
              <button id="builder_source_product" type="button" style="background: #fff; color: #17212b; border: 1px solid #d7dee7;">Product Link</button>
              <button id="builder_source_label" type="button" style="background: #fff; color: #17212b; border: 1px solid #d7dee7;">Label Photo</button>
              <button id="builder_source_manual" type="button" style="background: #fff; color: #17212b; border: 1px solid #d7dee7;">Manual Facts</button>
            </div>
            <p id="builder_source_hint" class="muted" style="margin: 8px 0 0;">Catalog mode: search local foods first, USDA secondary.</p>
          </div>

          <div class="grid" style="margin-top: 12px;">
            <div>
              <label for="builder_title">Meal Title</label>
              <input id="builder_title" placeholder="e.g., Daily Protein Shake" />
            </div>
            <div>
              <label for="builder_label">Meal Label</label>
              <input id="builder_label" placeholder="Breakfast / Snack / Post-workout" />
            </div>
          </div>

          <div id="builder-source-catalog">
            <div class="grid" style="margin-top: 12px;">
              <div style="grid-column: span 2;">
                <label for="builder_food_search">Ingredient Search</label>
                <input
                  id="builder_food_search"
                  placeholder="Type ingredient (e.g., banana, whey protein, almond milk)"
                  autocomplete="off"
                />
                <p class="muted" style="margin: 6px 0 0;">Search starts with your local food catalog. Use Search USDA only if needed.</p>
                <div id="builder-food-results" style="margin-top: 8px;"></div>
              </div>
              <div>
                <label for="builder_search_usda">&nbsp;</label>
                <button id="builder_search_usda" type="button">Search USDA</button>
              </div>
            </div>
          </div>

          <div id="builder-custom-card" class="card" style="margin-top: 12px; margin-bottom: 0; border-color: #d7dee7; background: #ffffff;">
            <h4 style="margin: 0 0 8px;">Custom Ingredient Input</h4>
            <p class="muted" style="margin: 0 0 10px;">
              Use this when catalog results are wrong or missing.
            </p>

            <div class="grid">
              <div>
                <label for="custom_ingredient_name">Ingredient Title</label>
                <input id="custom_ingredient_name" placeholder="e.g., Premium Organic Cacao Powder" />
              </div>
              <div>
                <label for="custom_quantity">Servings Used</label>
                <input id="custom_quantity" type="number" min="0" step="0.1" value="1" />
              </div>
              <div>
                <label for="custom_serving_size_value">Serving Size Value</label>
                <input id="custom_serving_size_value" type="number" min="0" step="0.1" placeholder="e.g., 6" />
              </div>
              <div>
                <label for="custom_serving_size_unit">Serving Size Unit</label>
                <select id="custom_serving_size_unit">
                  <option value="g">g</option>
                  <option value="ml">ml</option>
                  <option value="item">item</option>
                  <option value="tbsp">tbsp</option>
                  <option value="tsp">tsp</option>
                  <option value="cup">cup</option>
                  <option value="oz">oz</option>
                  <option value="lb">lb</option>
                </select>
              </div>
            </div>

            <div id="builder-product-controls" class="grid" style="margin-top: 10px;">
              <div style="grid-column: span 2;">
                <label for="custom_product_url">Product Link</label>
                <input id="custom_product_url" type="url" placeholder="https://..." />
              </div>
              <div>
                <label for="parse_product_link_btn">&nbsp;</label>
                <button id="parse_product_link_btn" type="button">Fetch Product Data</button>
              </div>
            </div>

            <div id="builder-label-controls" class="grid" style="margin-top: 10px;">
              <div style="grid-column: span 2;">
                <label for="label_photo_upload">Nutrition Label Photo</label>
                <input id="label_photo_upload" type="file" accept="image/*" capture="environment" />
              </div>
              <div>
                <label for="parse_label_btn">&nbsp;</label>
                <button id="parse_label_btn" type="button">Parse Label Photo</button>
              </div>
            </div>

            <div class="grid" style="margin-top: 10px;">
              <div>
                <label for="custom_calories">Calories (per serving)</label>
                <input id="custom_calories" type="number" min="0" step="0.1" />
              </div>
              <div>
                <label for="custom_protein_g">Protein g (per serving)</label>
                <input id="custom_protein_g" type="number" min="0" step="0.1" />
              </div>
              <div>
                <label for="custom_carbs_g">Carbs g (per serving)</label>
                <input id="custom_carbs_g" type="number" min="0" step="0.1" />
              </div>
              <div>
                <label for="custom_fat_g">Fat g (per serving)</label>
                <input id="custom_fat_g" type="number" min="0" step="0.1" />
              </div>
              <div>
                <label for="custom_sugar_g">Sugar g (per serving)</label>
                <input id="custom_sugar_g" type="number" min="0" step="0.1" />
              </div>
              <div>
                <label for="custom_sodium_mg">Sodium mg (per serving)</label>
                <input id="custom_sodium_mg" type="number" min="0" step="0.1" />
              </div>
            </div>

            <div class="grid" style="margin-top: 10px;">
              <div>
                <label for="add_custom_ingredient_btn">&nbsp;</label>
                <button id="add_custom_ingredient_btn" type="button">Add Custom Ingredient</button>
              </div>
              <div>
                <label for="cancel_edit_custom_ingredient_btn">&nbsp;</label>
                <button
                  id="cancel_edit_custom_ingredient_btn"
                  type="button"
                  style="display: none; background: #fff; color: #17212b; border: 1px solid #d7dee7;"
                >
                  Cancel Edit
                </button>
              </div>
            </div>
            <p id="label_parse_status" class="muted" style="margin: 8px 0 0;"></p>
          </div>

          <div style="overflow-x: auto; margin-top: 12px;">
            <table style="width: 100%; border-collapse: collapse;">
              <thead>
                <tr>
                  <th style="text-align: left; padding: 8px; border-bottom: 1px solid #d7dee7;">Ingredient</th>
                  <th style="text-align: left; padding: 8px; border-bottom: 1px solid #d7dee7;">Qty</th>
                  <th style="text-align: left; padding: 8px; border-bottom: 1px solid #d7dee7;">Unit</th>
                  <th style="text-align: right; padding: 8px; border-bottom: 1px solid #d7dee7;">Cal</th>
                  <th style="text-align: right; padding: 8px; border-bottom: 1px solid #d7dee7;">Protein</th>
                  <th style="text-align: right; padding: 8px; border-bottom: 1px solid #d7dee7;">Carbs</th>
                  <th style="text-align: right; padding: 8px; border-bottom: 1px solid #d7dee7;">Fat</th>
                  <th style="text-align: right; padding: 8px; border-bottom: 1px solid #d7dee7;">Sugar</th>
                  <th style="text-align: right; padding: 8px; border-bottom: 1px solid #d7dee7;">Sodium</th>
                  <th style="text-align: left; padding: 8px; border-bottom: 1px solid #d7dee7;">Action</th>
                </tr>
              </thead>
              <tbody id="builder-ingredients-body">
                <tr>
                  <td colspan="10" class="muted" style="padding: 8px;">No ingredients added yet.</td>
                </tr>
              </tbody>
            </table>
          </div>

          <div class="grid" style="margin-top: 12px;">
            <div>
              <div class="muted">Builder Calories</div>
              <div id="builder_total_calories" class="metric">0</div>
            </div>
            <div>
              <div class="muted">Builder Protein (g)</div>
              <div id="builder_total_protein" class="metric">0</div>
            </div>
            <div>
              <div class="muted">Builder Carbs (g)</div>
              <div id="builder_total_carbs" class="metric">0</div>
            </div>
            <div>
              <div class="muted">Builder Fat (g)</div>
              <div id="builder_total_fat" class="metric">0</div>
            </div>
            <div>
              <div class="muted">Builder Sugar (g)</div>
              <div id="builder_total_sugar" class="metric">0</div>
            </div>
            <div>
              <div class="muted">Builder Sodium (mg)</div>
              <div id="builder_total_sodium" class="metric">0</div>
            </div>
          </div>

          <div style="margin-top: 12px; display: flex; gap: 8px; flex-wrap: wrap;">
            <button id="builder_apply_to_form" type="button">Use Builder Totals</button>
            <button id="builder_clear" type="button" style="background: #fff; color: #17212b; border: 1px solid #d7dee7;">Clear Ingredients</button>
          </div>
          <p class="muted" style="margin-top: 8px;">
            Tip: enable "Save this entry as a favorite" to reuse this built meal later.
          </p>
        </div>
      </div>

      <div class="grid" style="margin-top: 12px;">
        <div>
          <label for="eaten_at">Eaten At</label>
          <input
            id="eaten_at"
            name="eaten_at"
            type="datetime-local"
            value="{{ edit_meal.eaten_at.strftime('%Y-%m-%dT%H:%M') if edit_meal else default_eaten_at }}"
            required
          />
        </div>
        <div>
          <label for="label">Meal Label</label>
          <input id="label" name="label" placeholder="Breakfast / Lunch / Dinner / Snack" value="{{ ((edit_meal.label if edit_meal else '') if (edit_meal and edit_meal.label not in ['None','none','NULL','null']) else '') }}" />
        </div>
        <div>
          <label for="portion_notes">Portion Notes</label>
          <input id="portion_notes" name="portion_notes" placeholder="1 bowl, 2 slices..." value="{{ ((edit_meal.portion_notes if edit_meal else '') if (edit_meal and edit_meal.portion_notes not in ['None','none','NULL','null']) else '') }}" />
        </div>
        <div>
          <label for="is_beverage">&nbsp;</label>
          <label style="display: inline-flex; align-items: center; gap: 8px; font-weight: 400;">
            <input id="is_beverage" name="is_beverage" type="checkbox" {% if edit_meal and edit_meal.is_beverage %}checked{% endif %} />
            This is a drink
          </label>
        </div>
      </div>

      <div style="margin-top: 12px;">
        <label for="description">Description</label>
        <textarea id="description" name="description" placeholder="What you ate/drank and context (prep, sauce, cravings, etc).">{{ ((edit_meal.description if edit_meal else '') if (edit_meal and edit_meal.description not in ['None','none','NULL','null']) else '') }}</textarea>
      </div>

      <details id="meal_advanced_section" style="margin-top: 12px;" {% if edit_meal %}open{% endif %}>
        <summary style="cursor: pointer; font-weight: 600;">Advanced (optional): favorites, tags, nutrition, photo</summary>
        <div style="margin-top: 12px;">
          <div class="grid">
            <div>
              <label for="favorite_selector">Load Favorite</label>
              <select id="favorite_selector">
                <option value="">Choose a favorite</option>
                {% for favorite in favorites %}
                  <option value="{{ favorite.id }}">{{ favorite.name }}</option>
                {% endfor %}
              </select>
            </div>
            <div>
              <label for="save_favorite">&nbsp;</label>
              <label style="display: inline-flex; align-items: center; gap: 8px; font-weight: 400;">
                <input id="save_favorite" name="save_favorite" type="checkbox" />
                Save this entry as a favorite
              </label>
            </div>
            <div>
              <label for="favorite_name">Favorite Name</label>
              <input id="favorite_name" name="favorite_name" placeholder="e.g., weekday breakfast" />
            </div>
          </div>

          <div class="grid" style="margin-top: 12px;">
            <div>
              <label for="tags">Tags (comma-separated)</label>
              <input id="tags" name="tags" placeholder="high_carb, processed, salty" value="{{ (edit_meal.tags | join(', ')) if edit_meal and edit_meal.tags else '' }}" />
            </div>
            <div>
              <label for="calories">Calories</label>
              <input id="calories" name="calories" type="number" min="0" value="{{ edit_meal.calories if edit_meal and edit_meal.calories is not none else '' }}" />
            </div>
            <div>
              <label for="protein_g">Protein (g)</label>
              <input id="protein_g" name="protein_g" type="number" min="0" step="0.1" value="{{ edit_meal.protein_g if edit_meal and edit_meal.protein_g is not none else '' }}" />
            </div>
            <div>
              <label for="carbs_g">Carbs (g)</label>
              <input id="carbs_g" name="carbs_g" type="number" min="0" step="0.1" value="{{ edit_meal.carbs_g if edit_meal and edit_meal.carbs_g is not none else '' }}" />
            </div>
            <div>
              <label for="fat_g">Fat (g)</label>
              <input id="fat_g" name="fat_g" type="number" min="0" step="0.1" value="{{ edit_meal.fat_g if edit_meal and edit_meal.fat_g is not none else '' }}" />
            </div>
            <div>
              <label for="sugar_g">Sugar (g)</label>
              <input id="sugar_g" name="sugar_g" type="number" min="0" step="0.1" value="{{ edit_meal.sugar_g if edit_meal and edit_meal.sugar_g is not none else '' }}" />
            </div>
            <div>
              <label for="sodium_mg">Sodium (mg)</label>
              <input id="sodium_mg" name="sodium_mg" type="number" min="0" step="0.1" value="{{ edit_meal.sodium_mg if edit_meal and edit_meal.sodium_mg is not none else '' }}" />
            </div>
            <div>
              <label for="photo">Photo (optional)</label>
              <input id="photo" name="photo" type="file" accept=".png,.jpg,.jpeg,.webp,.heic" />
            </div>
          </div>
        </div>
      </details>

      <div style="margin-top: 12px; display: flex; gap: 8px; flex-wrap: wrap;">
        <button type="submit">{{ "Update Meal" if edit_meal else "Save Meal" }}</button>
        {% if edit_meal %}
          <a href="{{ url_for('main.meal_form', day=selected_day) }}" style="padding: 10px 14px; background: #fff; border: 1px solid #d7dee7; border-radius: 8px; text-decoration: none; color: #17212b;">Cancel Edit</a>
        {% endif %}
      </div>
    </form>
  </div>

  <div class="card">
    <h2>Entries For {{ selected_day }}</h2>
    {% if day_meals %}
      <div style="overflow-x: auto;">
        <table style="width: 100%; border-collapse: collapse;">
          <thead>
            <tr>
              <th style="text-align: left; padding: 8px; border-bottom: 1px solid #d7dee7;">Time</th>
              <th style="text-align: left; padding: 8px; border-bottom: 1px solid #d7dee7;">Type</th>
              <th style="text-align: left; padding: 8px; border-bottom: 1px solid #d7dee7;">Item</th>
              <th style="text-align: left; padding: 8px; border-bottom: 1px solid #d7dee7;">Portion</th>
              <th style="text-align: right; padding: 8px; border-bottom: 1px solid #d7dee7;">Calories</th>
              <th style="text-align: right; padding: 8px; border-bottom: 1px solid #d7dee7;">P/C/F</th>
              <th style="text-align: left; padding: 8px; border-bottom: 1px solid #d7dee7;">Actions</th>
            </tr>
          </thead>
          <tbody>
            {% for meal in day_meals %}
              <tr>
                <td style="padding: 8px; border-bottom: 1px solid #eef3f8;">{{ meal.eaten_at.strftime("%H:%M") }}</td>
                <td style="padding: 8px; border-bottom: 1px solid #eef3f8;">{{ "Drink" if meal.is_beverage else "Food" }}</td>
                <td style="padding: 8px; border-bottom: 1px solid #eef3f8;">
                  {% if meal.food_item %}
                    {{ meal.food_item.display_name() }}
                  {% elif meal.description and meal.description|lower not in ["none", "null"] %}
                    {{ meal.description }}
                  {% else %}
                    Custom entry
                  {% endif %}
                </td>
                <td style="padding: 8px; border-bottom: 1px solid #eef3f8;">
                  {% if meal.portion_notes and meal.portion_notes|lower not in ["none", "null"] %}
                    {{ meal.portion_notes }}
                  {% else %}
                    n/a
                  {% endif %}
                </td>
                <td style="padding: 8px; border-bottom: 1px solid #eef3f8; text-align: right;">{{ meal.calories if meal.calories is not none else "-" }}</td>
                <td style="padding: 8px; border-bottom: 1px solid #eef3f8; text-align: right;">
                  {{ meal.protein_g if meal.protein_g is not none else "-" }}/{{ meal.carbs_g if meal.carbs_g is not none else "-" }}/{{ meal.fat_g if meal.fat_g is not none else "-" }}
                </td>
                <td style="padding: 8px; border-bottom: 1px solid #eef3f8;">
                  <a href="{{ url_for('main.meal_edit', meal_id=meal.id) }}">Edit</a>
                  <form method="post" action="{{ url_for('main.meal_delete', meal_id=meal.id) }}" style="display: inline;">
                    <input type="hidden" name="day" value="{{ selected_day }}" />
                    <button type="submit" style="margin-left: 8px; background: #fff; color: #b42318; border: 1px solid #f1c0bc;">Delete</button>
                  </form>
                </td>
              </tr>
            {% endfor %}
          </tbody>
        </table>
      </div>
    {% else %}
      <p class="muted">No food or drink entries yet for this day.</p>
    {% endif %}
  </div>

  <script>
    const favoritePayload = {{ favorite_payload | tojson }};
    const isEditMode = {{ "true" if edit_meal else "false" }};
    const mealForm = document.getElementById("meal-form");
    const favoriteSelector = document.getElementById("favorite_selector");
    const foodSearchInput = document.getElementById("food_search");
    const foodResults = document.getElementById("food-results");
    const foodItemIdInput = document.getElementById("food_item_id");
    const searchUsdaButton = document.getElementById("search_usda");
    const favoriteIngredientsInput = document.getElementById("favorite_ingredients");

    const entryModeSingleButton = document.getElementById("entry_mode_single");
    const entryModeRecipeButton = document.getElementById("entry_mode_recipe");
    const entryModeHint = document.getElementById("entry_mode_hint");
    const singleEntryPanel = document.getElementById("single-entry-panel");
    const recipeEntryPanel = document.getElementById("recipe-entry-panel");

    const builderToggle = document.getElementById("builder_toggle");
    const mealBuilderPanel = document.getElementById("meal-builder-panel");
    const builderTitleInput = document.getElementById("builder_title");
    const builderLabelInput = document.getElementById("builder_label");
    const builderFoodSearchInput = document.getElementById("builder_food_search");
    const builderFoodResults = document.getElementById("builder-food-results");
    const builderSearchUsdaButton = document.getElementById("builder_search_usda");
    const builderIngredientsBody = document.getElementById("builder-ingredients-body");
    const builderApplyButton = document.getElementById("builder_apply_to_form");
    const builderClearButton = document.getElementById("builder_clear");
    const builderSourceCatalogButton = document.getElementById("builder_source_catalog");
    const builderSourceProductButton = document.getElementById("builder_source_product");
    const builderSourceLabelButton = document.getElementById("builder_source_label");
    const builderSourceManualButton = document.getElementById("builder_source_manual");
    const builderSourceHint = document.getElementById("builder_source_hint");
    const builderSourceCatalogPanel = document.getElementById("builder-source-catalog");
    const builderCustomCard = document.getElementById("builder-custom-card");
    const builderProductControls = document.getElementById("builder-product-controls");
    const builderLabelControls = document.getElementById("builder-label-controls");

    const customIngredientName = document.getElementById("custom_ingredient_name");
    const customProductUrl = document.getElementById("custom_product_url");
    const parseProductLinkButton = document.getElementById("parse_product_link_btn");
    const customQuantity = document.getElementById("custom_quantity");
    const customServingSizeValue = document.getElementById("custom_serving_size_value");
    const customServingSizeUnit = document.getElementById("custom_serving_size_unit");
    const customCalories = document.getElementById("custom_calories");
    const customProtein = document.getElementById("custom_protein_g");
    const customCarbs = document.getElementById("custom_carbs_g");
    const customFat = document.getElementById("custom_fat_g");
    const customSugar = document.getElementById("custom_sugar_g");
    const customSodium = document.getElementById("custom_sodium_mg");
    const labelPhotoUpload = document.getElementById("label_photo_upload");
    const parseLabelButton = document.getElementById("parse_label_btn");
    const addCustomIngredientButton = document.getElementById("add_custom_ingredient_btn");
    const cancelEditCustomIngredientButton = document.getElementById("cancel_edit_custom_ingredient_btn");
    const labelParseStatus = document.getElementById("label_parse_status");
    const builderTotals = {
      calories: document.getElementById("builder_total_calories"),
      protein: document.getElementById("builder_total_protein"),
      carbs: document.getElementById("builder_total_carbs"),
      fat: document.getElementById("builder_total_fat"),
      sugar: document.getElementById("builder_total_sugar"),
      sodium: document.getElementById("builder_total_sodium"),
    };

    const builderState = { ingredients: [], editingRowId: null, source: "catalog", mode: "single" };
    const unitOptions = ["serving", "g", "oz", "lb", "ml", "cup", "tbsp", "tsp", "item"];

    const fieldMap = {
      label: document.getElementById("label"),
      description: document.getElementById("description"),
      portion_notes: document.getElementById("portion_notes"),
      tags: document.getElementById("tags"),
      calories: document.getElementById("calories"),
      protein_g: document.getElementById("protein_g"),
      carbs_g: document.getElementById("carbs_g"),
      fat_g: document.getElementById("fat_g"),
      sugar_g: document.getElementById("sugar_g"),
      sodium_mg: document.getElementById("sodium_mg"),
      is_beverage: document.getElementById("is_beverage"),
    };

    function escapeHtml(text) {
      return String(text || "")
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#39;");
    }

    function displayNumber(value, digits = 1) {
      if (!Number.isFinite(value)) return "-";
      const fixed = value.toFixed(digits);
      return digits > 0 ? fixed.replace(/\.0$/, "") : fixed;
    }

    function cleanText(value) {
      return String(value || "")
        .replace(/\s+/g, " ")
        .trim();
    }

    function setToggleButtonState(button, active) {
      if (!button) return;
      if (active) {
        button.style.background = "var(--accent)";
        button.style.color = "#fff";
        button.style.border = "none";
      } else {
        button.style.background = "#fff";
        button.style.color = "#17212b";
        button.style.border = "1px solid #d7dee7";
      }
    }

    function setEntryMode(mode) {
      const nextMode = mode === "recipe" ? "recipe" : "single";
      builderState.mode = nextMode;
      const isRecipe = nextMode === "recipe";

      if (singleEntryPanel) singleEntryPanel.style.display = isRecipe ? "none" : "block";
      if (recipeEntryPanel) recipeEntryPanel.style.display = isRecipe ? "block" : "none";

      setToggleButtonState(entryModeSingleButton, !isRecipe);
      setToggleButtonState(entryModeRecipeButton, isRecipe);

      if (entryModeHint) {
        entryModeHint.textContent = isRecipe
          ? "Build Recipe mode: add ingredients, apply totals, then save."
          : "Single Item mode: fastest way to log one food/drink.";
      }

      if (isRecipe) {
        setBuilderOpen(true);
      } else {
        setBuilderOpen(false);
      }
    }

    function setBuilderSource(source) {
      const allowed = new Set(["catalog", "product", "label", "manual"]);
      const nextSource = allowed.has(source) ? source : "catalog";
      builderState.source = nextSource;

      setToggleButtonState(builderSourceCatalogButton, nextSource === "catalog");
      setToggleButtonState(builderSourceProductButton, nextSource === "product");
      setToggleButtonState(builderSourceLabelButton, nextSource === "label");
      setToggleButtonState(builderSourceManualButton, nextSource === "manual");

      if (builderSourceCatalogPanel) {
        builderSourceCatalogPanel.style.display = nextSource === "catalog" ? "block" : "none";
      }
      if (builderCustomCard) {
        builderCustomCard.style.display = nextSource === "catalog" ? "none" : "block";
      }
      if (builderProductControls) {
        builderProductControls.style.display = nextSource === "product" ? "grid" : "none";
      }
      if (builderLabelControls) {
        builderLabelControls.style.display = nextSource === "label" ? "grid" : "none";
      }

      if (builderSourceHint) {
        if (nextSource === "catalog") {
          builderSourceHint.textContent = "Catalog mode: search your local foods first. Use USDA only if needed.";
        } else if (nextSource === "product") {
          builderSourceHint.textContent = "Product Link mode: paste a product URL, fetch nutrition, then add ingredient.";
        } else if (nextSource === "label") {
          builderSourceHint.textContent = "Label Photo mode: take/upload nutrition label photo, review parsed values, then add.";
        } else {
          builderSourceHint.textContent = "Manual Facts mode: type nutrition values from a package label or your own data.";
        }
      }
    }

    function normalizeUnit(unit) {
      const raw = String(unit || "").trim().toLowerCase();
      const aliases = {
        gram: "g",
        grams: "g",
        kilogram: "kg",
        kilograms: "kg",
        ounce: "oz",
        ounces: "oz",
        pound: "lb",
        pounds: "lb",
        milliliter: "ml",
        milliliters: "ml",
        liter: "l",
        liters: "l",
        tablespoon: "tbsp",
        tablespoons: "tbsp",
        teaspoon: "tsp",
        teaspoons: "tsp",
        pieces: "item",
        piece: "item",
        slices: "item",
        slice: "item",
        bottle: "item",
        bottles: "item",
      };
      return aliases[raw] || raw;
    }

    function unitToWeightGrams(quantity, unit) {
      const normalized = normalizeUnit(unit);
      const map = { g: 1, kg: 1000, oz: 28.3495, lb: 453.59237 };
      if (!map[normalized]) return null;
      return quantity * map[normalized];
    }

    function unitToVolumeMl(quantity, unit) {
      const normalized = normalizeUnit(unit);
      const map = { ml: 1, l: 1000, cup: 240, tbsp: 15, tsp: 5 };
      if (!map[normalized]) return null;
      return quantity * map[normalized];
    }

    function isCountUnit(unit) {
      return normalizeUnit(unit) === "item";
    }

    function computeMultiplier(row) {
      const quantity = Number(row.quantity || 0);
      if (!Number.isFinite(quantity) || quantity <= 0) return 0;

      const chosenUnit = normalizeUnit(row.unit || "serving");
      if (chosenUnit === "serving") return quantity;

      const servingSize = Number(row.serving_size || 0);
      const servingUnit = normalizeUnit(row.serving_unit || "");
      if (!Number.isFinite(servingSize) || servingSize <= 0 || !servingUnit) return quantity;

      if (chosenUnit === servingUnit) {
        return quantity / servingSize;
      }

      const chosenWeight = unitToWeightGrams(quantity, chosenUnit);
      const servingWeight = unitToWeightGrams(servingSize, servingUnit);
      if (chosenWeight !== null && servingWeight !== null && servingWeight > 0) {
        return chosenWeight / servingWeight;
      }

      const chosenVolume = unitToVolumeMl(quantity, chosenUnit);
      const servingVolume = unitToVolumeMl(servingSize, servingUnit);
      if (chosenVolume !== null && servingVolume !== null && servingVolume > 0) {
        return chosenVolume / servingVolume;
      }

      if (isCountUnit(chosenUnit) && isCountUnit(servingUnit)) {
        return quantity / servingSize;
      }

      return quantity;
    }

    function scaledNutrient(row, key, isCalories = false) {
      const base = Number(row[key]);
      if (!Number.isFinite(base)) return null;
      const scaled = base * computeMultiplier(row);
      return isCalories ? Math.round(scaled) : Number(scaled.toFixed(1));
    }

    function syncFavoriteIngredientsField() {
      if (!favoriteIngredientsInput) return;
      if (!builderState.ingredients.length) {
        favoriteIngredientsInput.value = "";
        return;
      }

      const payload = builderState.ingredients.map((row) => ({
        food_item_id: row.food_item_id || null,
        food_name: row.food_name || null,
        quantity: Number(row.quantity || 0),
        unit: normalizeUnit(row.unit || "serving"),
        serving_size: row.serving_size ?? null,
        serving_unit: row.serving_unit || null,
        calories: row.calories ?? null,
        protein_g: row.protein_g ?? null,
        carbs_g: row.carbs_g ?? null,
        fat_g: row.fat_g ?? null,
        sugar_g: row.sugar_g ?? null,
        sodium_mg: row.sodium_mg ?? null,
      }));
      favoriteIngredientsInput.value = JSON.stringify(payload);
    }

    function updateBuilderTotals() {
      let calories = 0;
      let protein = 0;
      let carbs = 0;
      let fat = 0;
      let sugar = 0;
      let sodium = 0;

      builderState.ingredients.forEach((row) => {
        calories += Number(scaledNutrient(row, "calories", true) || 0);
        protein += Number(scaledNutrient(row, "protein_g") || 0);
        carbs += Number(scaledNutrient(row, "carbs_g") || 0);
        fat += Number(scaledNutrient(row, "fat_g") || 0);
        sugar += Number(scaledNutrient(row, "sugar_g") || 0);
        sodium += Number(scaledNutrient(row, "sodium_mg") || 0);
      });

      if (builderTotals.calories) builderTotals.calories.textContent = String(Math.round(calories));
      if (builderTotals.protein) builderTotals.protein.textContent = displayNumber(protein, 1);
      if (builderTotals.carbs) builderTotals.carbs.textContent = displayNumber(carbs, 1);
      if (builderTotals.fat) builderTotals.fat.textContent = displayNumber(fat, 1);
      if (builderTotals.sugar) builderTotals.sugar.textContent = displayNumber(sugar, 1);
      if (builderTotals.sodium) builderTotals.sodium.textContent = displayNumber(sodium, 1);

      syncFavoriteIngredientsField();
      return { calories, protein, carbs, fat, sugar, sodium };
    }

    function renderBuilderIngredients() {
      if (!builderIngredientsBody) return;
      if (!builderState.ingredients.length) {
        builderIngredientsBody.innerHTML = '<tr><td colspan="10" class="muted" style="padding: 8px;">No ingredients added yet.</td></tr>';
        updateBuilderTotals();
        return;
      }

      builderIngredientsBody.innerHTML = builderState.ingredients
        .map((row) => {
          const calories = scaledNutrient(row, "calories", true);
          const protein = scaledNutrient(row, "protein_g");
          const carbs = scaledNutrient(row, "carbs_g");
          const fat = scaledNutrient(row, "fat_g");
          const sugar = scaledNutrient(row, "sugar_g");
          const sodium = scaledNutrient(row, "sodium_mg");
          const servingHint = row.serving_size && row.serving_unit
            ? `${displayNumber(Number(row.serving_size), 1)} ${escapeHtml(row.serving_unit)}`
            : "serving n/a";

          const options = unitOptions
            .map((unit) => `<option value="${unit}" ${normalizeUnit(row.unit) === unit ? "selected" : ""}>${unit}</option>`)
            .join("");

          return `
            <tr>
              <td style="padding: 8px; border-bottom: 1px solid #eef3f8;">
                <strong>${escapeHtml(row.food_name || "Ingredient")}</strong>
                <div class="muted">base: ${servingHint}</div>
              </td>
              <td style="padding: 8px; border-bottom: 1px solid #eef3f8; min-width: 90px;">
                <input type="number" min="0" step="0.1" value="${escapeHtml(row.quantity)}" data-row-id="${row.row_id}" data-field="quantity" />
              </td>
              <td style="padding: 8px; border-bottom: 1px solid #eef3f8; min-width: 100px;">
                <select data-row-id="${row.row_id}" data-field="unit">${options}</select>
              </td>
              <td style="padding: 8px; border-bottom: 1px solid #eef3f8; text-align: right;">${calories ?? "-"}</td>
              <td style="padding: 8px; border-bottom: 1px solid #eef3f8; text-align: right;">${displayNumber(Number(protein), 1)}</td>
              <td style="padding: 8px; border-bottom: 1px solid #eef3f8; text-align: right;">${displayNumber(Number(carbs), 1)}</td>
              <td style="padding: 8px; border-bottom: 1px solid #eef3f8; text-align: right;">${displayNumber(Number(fat), 1)}</td>
              <td style="padding: 8px; border-bottom: 1px solid #eef3f8; text-align: right;">${displayNumber(Number(sugar), 1)}</td>
              <td style="padding: 8px; border-bottom: 1px solid #eef3f8; text-align: right;">${displayNumber(Number(sodium), 1)}</td>
              <td style="padding: 8px; border-bottom: 1px solid #eef3f8;">
                <button type="button" data-row-id="${row.row_id}" data-action="edit" style="background:#fff;color:#17212b;border:1px solid #d7dee7;margin-right:6px;">Edit</button>
                <button type="button" data-row-id="${row.row_id}" data-action="remove" style="background:#fff;color:#b42318;border:1px solid #f1c0bc;">Remove</button>
              </td>
            </tr>
          `;
        })
        .join("");

      updateBuilderTotals();
    }

    function addIngredientFromFood(food) {
      if (!food) return;
      setEntryMode("recipe");
      setBuilderSource("catalog");
      setCustomIngredientEditMode(null);
      clearCustomIngredientInputs();
      builderState.ingredients.push({
        row_id: `row_${Date.now()}_${Math.floor(Math.random() * 100000)}`,
        food_item_id: food.id || null,
        food_name: food.display_name || food.name || "Ingredient",
        quantity: 1,
        unit: "serving",
        serving_size: food.serving_size ?? null,
        serving_unit: food.serving_unit ?? null,
        calories: food.calories ?? null,
        protein_g: food.protein_g ?? null,
        carbs_g: food.carbs_g ?? null,
        fat_g: food.fat_g ?? null,
        sugar_g: food.sugar_g ?? null,
        sodium_mg: food.sodium_mg ?? null,
      });
      renderBuilderIngredients();
    }

    function readFloatInput(input, fallback = null) {
      if (!input) return fallback;
      const value = Number(input.value);
      return Number.isFinite(value) ? value : fallback;
    }

    function setLabelStatus(message, isError = false) {
      if (!labelParseStatus) return;
      labelParseStatus.textContent = message || "";
      labelParseStatus.style.color = isError ? "#b42318" : "";
    }

    function clearCustomIngredientInputs(resetStatus = true) {
      if (customIngredientName) customIngredientName.value = "";
      if (customProductUrl) customProductUrl.value = "";
      if (customQuantity) customQuantity.value = "1";
      if (customServingSizeValue) customServingSizeValue.value = "";
      if (customServingSizeUnit) customServingSizeUnit.value = "g";
      if (customCalories) customCalories.value = "";
      if (customProtein) customProtein.value = "";
      if (customCarbs) customCarbs.value = "";
      if (customFat) customFat.value = "";
      if (customSugar) customSugar.value = "";
      if (customSodium) customSodium.value = "";
      if (labelPhotoUpload) labelPhotoUpload.value = "";
      if (resetStatus) setLabelStatus("");
    }

    function setCustomIngredientEditMode(rowId = null) {
      builderState.editingRowId = rowId;
      if (addCustomIngredientButton) {
        addCustomIngredientButton.textContent = rowId ? "Update Ingredient" : "Add Custom Ingredient";
      }
      if (cancelEditCustomIngredientButton) {
        cancelEditCustomIngredientButton.style.display = rowId ? "inline-block" : "none";
      }
    }

    function populateCustomInputsFromIngredientRow(row) {
      if (!row) return;
      if (customIngredientName) customIngredientName.value = row.food_name || "";
      if (customProductUrl) customProductUrl.value = "";
      if (customQuantity) customQuantity.value = String(row.quantity ?? 1);
      if (customServingSizeValue) {
        customServingSizeValue.value = row.serving_size !== null && row.serving_size !== undefined ? String(row.serving_size) : "";
      }
      if (customServingSizeUnit) {
        customServingSizeUnit.value = normalizeUnit(row.serving_unit || "g");
      }
      if (customCalories) customCalories.value = row.calories ?? "";
      if (customProtein) customProtein.value = row.protein_g ?? "";
      if (customCarbs) customCarbs.value = row.carbs_g ?? "";
      if (customFat) customFat.value = row.fat_g ?? "";
      if (customSugar) customSugar.value = row.sugar_g ?? "";
      if (customSodium) customSodium.value = row.sodium_mg ?? "";
      setEntryMode("recipe");
      setBuilderSource("manual");
      setBuilderOpen(true);
      setLabelStatus("Editing ingredient. Update fields, then click Update Ingredient.");
    }

    function addCustomIngredientFromInputs() {
      const name = (customIngredientName?.value || "").trim();
      const quantity = readFloatInput(customQuantity, 1);
      const servingSize = readFloatInput(customServingSizeValue, null);
      const servingUnit = (customServingSizeUnit?.value || "g").trim();

      if (!name) {
        setLabelStatus("Add an ingredient title before adding.", true);
        return;
      }

      const calories = readFloatInput(customCalories, null);
      const protein = readFloatInput(customProtein, null);
      const carbs = readFloatInput(customCarbs, null);
      const fat = readFloatInput(customFat, null);
      const sugar = readFloatInput(customSugar, null);
      const sodium = readFloatInput(customSodium, null);

      const normalizedQuantity = Number.isFinite(quantity) && quantity > 0 ? quantity : 1;
      const editRow = builderState.ingredients.find((item) => item.row_id === builderState.editingRowId);

      if (editRow) {
        editRow.food_name = name;
        editRow.quantity = normalizedQuantity;
        editRow.unit = "serving";
        editRow.serving_size = servingSize;
        editRow.serving_unit = servingUnit || "g";
        editRow.calories = calories;
        editRow.protein_g = protein;
        editRow.carbs_g = carbs;
        editRow.fat_g = fat;
        editRow.sugar_g = sugar;
        editRow.sodium_mg = sodium;
      } else {
        builderState.ingredients.push({
          row_id: `custom_${Date.now()}_${Math.floor(Math.random() * 100000)}`,
          food_item_id: null,
          food_name: name,
          quantity: normalizedQuantity,
          unit: "serving",
          serving_size: servingSize,
          serving_unit: servingUnit || "g",
          calories: calories,
          protein_g: protein,
          carbs_g: carbs,
          fat_g: fat,
          sugar_g: sugar,
          sodium_mg: sodium,
        });
      }
      renderBuilderIngredients();
      setEntryMode("recipe");
      setBuilderSource("manual");
      setBuilderOpen(true);
      clearCustomIngredientInputs(false);
      setCustomIngredientEditMode(null);
      setLabelStatus(editRow ? "Ingredient updated." : "Custom ingredient added and form cleared.");
      if (customIngredientName) customIngredientName.focus();
    }

    function populateCustomInputsFromParsed(parsed) {
      if (!parsed) return;
      if (customIngredientName && parsed.name) customIngredientName.value = parsed.name;
      if (customServingSizeValue && parsed.serving_size_value !== null && parsed.serving_size_value !== undefined) {
        customServingSizeValue.value = parsed.serving_size_value;
      }
      if (customServingSizeUnit && parsed.serving_size_unit) {
        customServingSizeUnit.value = normalizeUnit(parsed.serving_size_unit);
      }
      if (customCalories && parsed.calories !== null && parsed.calories !== undefined) customCalories.value = parsed.calories;
      if (customProtein && parsed.protein_g !== null && parsed.protein_g !== undefined) customProtein.value = parsed.protein_g;
      if (customCarbs && parsed.carbs_g !== null && parsed.carbs_g !== undefined) customCarbs.value = parsed.carbs_g;
      if (customFat && parsed.fat_g !== null && parsed.fat_g !== undefined) customFat.value = parsed.fat_g;
      if (customSugar && parsed.sugar_g !== null && parsed.sugar_g !== undefined) customSugar.value = parsed.sugar_g;
      if (customSodium && parsed.sodium_mg !== null && parsed.sodium_mg !== undefined) customSodium.value = parsed.sodium_mg;
    }

    async function parseNutritionLabelPhoto() {
      if (!labelPhotoUpload || !labelPhotoUpload.files || labelPhotoUpload.files.length === 0) {
        setLabelStatus("Choose a nutrition label photo first.", true);
        return;
      }

      const file = labelPhotoUpload.files[0];
      const formData = new FormData();
      formData.append("label_photo", file);
      formData.append("ingredient_name", (customIngredientName?.value || "").trim());

      setLabelStatus("Parsing label...");
      try {
        const response = await fetch("/nutrition/label/parse", {
          method: "POST",
          body: formData,
        });
        const data = await response.json();
        if (!response.ok || !data.ok) {
          setLabelStatus(data.error || "Could not parse label photo.", true);
          return;
        }
        populateCustomInputsFromParsed(data.parsed || {});
        const confidence = data.parsed?.confidence;
        if (confidence !== null && confidence !== undefined) {
          setLabelStatus(`Label parsed. Confidence ${displayNumber(Number(confidence) * 100, 0)}%. Review and edit if needed.`);
        } else {
          setLabelStatus("Label parsed. Review and edit if needed.");
        }
      } catch (error) {
        setLabelStatus("Label parse request failed. You can still enter values manually.", true);
      }
    }

    async function parseProductLink() {
      const url = (customProductUrl?.value || "").trim();
      if (!url) {
        setLabelStatus("Paste a product link first.", true);
        return;
      }

      const body = new URLSearchParams();
      body.set("product_url", url);
      body.set("ingredient_name", (customIngredientName?.value || "").trim());

      setLabelStatus("Fetching product page...");
      try {
        const response = await fetch("/nutrition/product/parse", {
          method: "POST",
          headers: { "Content-Type": "application/x-www-form-urlencoded" },
          body: body.toString(),
        });
        const data = await response.json();
        if (!response.ok || !data.ok) {
          setLabelStatus(data.error || "Could not parse product page.", true);
          return;
        }

        populateCustomInputsFromParsed(data.parsed || {});
        const confidence = data.parsed?.confidence;
        const sourceMethod = data.parsed?.source_method ? ` (${data.parsed.source_method})` : "";
        if (confidence !== null && confidence !== undefined) {
          setLabelStatus(
            `Product data loaded${sourceMethod}. Confidence ${displayNumber(Number(confidence) * 100, 0)}%. Review before adding.`,
          );
        } else {
          setLabelStatus(`Product data loaded${sourceMethod}. Review before adding.`);
        }
      } catch (error) {
        setLabelStatus("Product link request failed. Use manual data or label photo.", true);
      }
    }

    function loadFavoriteIngredients(ingredients) {
      if (!Array.isArray(ingredients) || ingredients.length === 0) return;
      builderState.ingredients = ingredients.map((item, index) => ({
        row_id: `fav_${Date.now()}_${index}`,
        food_item_id: item.food_item_id || null,
        food_name: item.food_name || "Ingredient",
        quantity: Number(item.quantity || 0) > 0 ? Number(item.quantity) : 1,
        unit: normalizeUnit(item.unit || "serving"),
        serving_size: item.serving_size ?? null,
        serving_unit: item.serving_unit ?? null,
        calories: item.calories ?? null,
        protein_g: item.protein_g ?? null,
        carbs_g: item.carbs_g ?? null,
        fat_g: item.fat_g ?? null,
        sugar_g: item.sugar_g ?? null,
        sodium_mg: item.sodium_mg ?? null,
      }));
      setCustomIngredientEditMode(null);
      clearCustomIngredientInputs();
      setEntryMode("recipe");
      setBuilderSource("catalog");
      setBuilderOpen(true);
      renderBuilderIngredients();
    }

    function setBuilderOpen(open) {
      if (!mealBuilderPanel || !builderToggle) return;
      mealBuilderPanel.style.display = open ? "block" : "none";
      builderToggle.textContent = open ? "Hide Builder" : "Build a Meal";
    }

    function applyBuilderToMealForm() {
      const totals = updateBuilderTotals();
      if (!builderState.ingredients.length) return;

      if (fieldMap.calories) fieldMap.calories.value = String(Math.round(totals.calories));
      if (fieldMap.protein_g) fieldMap.protein_g.value = totals.protein.toFixed(1);
      if (fieldMap.carbs_g) fieldMap.carbs_g.value = totals.carbs.toFixed(1);
      if (fieldMap.fat_g) fieldMap.fat_g.value = totals.fat.toFixed(1);
      if (fieldMap.sugar_g) fieldMap.sugar_g.value = totals.sugar.toFixed(1);
      if (fieldMap.sodium_mg) fieldMap.sodium_mg.value = totals.sodium.toFixed(1);

      const builderTitle = (builderTitleInput?.value || "").trim();
      const builderLabel = (builderLabelInput?.value || "").trim();
      const ingredientSummary = builderState.ingredients.map((item) => item.food_name).slice(0, 6).join(", ");

      if (builderLabel && fieldMap.label) {
        fieldMap.label.value = builderLabel;
      }
      if (builderTitle && fieldMap.description) {
        fieldMap.description.value = `${builderTitle}: ${ingredientSummary}`;
      } else if (fieldMap.description) {
        fieldMap.description.value = ingredientSummary;
      }
      if (fieldMap.portion_notes) {
        fieldMap.portion_notes.value = `Built meal (${builderState.ingredients.length} ingredients)`;
      }

      foodItemIdInput.value = "";
      if (foodSearchInput) {
        foodSearchInput.value = builderTitle || "Custom built meal";
      }
    }

    function applyFoodOrFavorite(data) {
      if (!data) return;
      const hasIngredients = Array.isArray(data.ingredients) && data.ingredients.length > 0;
      setEntryMode(hasIngredients ? "recipe" : "single");

      if (data.id !== undefined && data.id !== null) {
        foodItemIdInput.value = data.id;
      } else if (data.food_item_id) {
        foodItemIdInput.value = data.food_item_id;
      }

      if (foodSearchInput) {
        foodSearchInput.value = data.display_name || data.name || data.food_name || "";
      }

      if (fieldMap.description && !fieldMap.description.value) {
        fieldMap.description.value = data.display_name || data.description || data.name || "";
      } else if (data.description && !fieldMap.description.value) {
        fieldMap.description.value = data.description;
      }

      if (data.serving_size && data.serving_unit && fieldMap.portion_notes && !fieldMap.portion_notes.value) {
        fieldMap.portion_notes.value = `${data.serving_size} ${data.serving_unit}`;
      } else if (data.portion_notes && !fieldMap.portion_notes.value) {
        fieldMap.portion_notes.value = data.portion_notes;
      }

      if (data.label && fieldMap.label && !fieldMap.label.value) fieldMap.label.value = data.label;
      if (data.tags && fieldMap.tags && !fieldMap.tags.value) fieldMap.tags.value = data.tags;

      ["calories", "protein_g", "carbs_g", "fat_g", "sugar_g", "sodium_mg"].forEach((key) => {
        if (fieldMap[key] && (fieldMap[key].value === "" || fieldMap[key].value === null)) {
          if (data[key] !== undefined && data[key] !== null) {
            fieldMap[key].value = data[key];
          }
        }
      });

      if (typeof data.is_beverage === "boolean" && fieldMap.is_beverage) {
        fieldMap.is_beverage.checked = data.is_beverage;
      }

      if (hasIngredients) {
        if (builderTitleInput && !builderTitleInput.value) {
          builderTitleInput.value = data.name || data.display_name || "";
        }
        if (builderLabelInput && data.label) {
          builderLabelInput.value = data.label;
        }
        loadFavoriteIngredients(data.ingredients);
      }
    }

    if (favoriteSelector) {
      favoriteSelector.addEventListener("change", () => {
        const selectedId = Number(favoriteSelector.value);
        if (!selectedId) return;
        const favorite = favoritePayload.find((item) => item.id === selectedId);
        applyFoodOrFavorite(favorite);
      });
    }

    let lastSearchToken = 0;
    let debounceTimer;
    let lastBuilderSearchToken = 0;
    let builderDebounceTimer;

    function renderSearchButtons(targetElement, items, onPick, message = "") {
      if (!targetElement) return;
      const normalizedItems = (items || []).filter((item) => {
        const label = cleanText(item?.display_name || item?.name || item?.food_name || item?.brand);
        const hasMacro =
          item?.calories !== null ||
          item?.protein_g !== null ||
          item?.carbs_g !== null ||
          item?.fat_g !== null ||
          item?.sugar_g !== null;
        return Boolean(label) || hasMacro;
      });

      if (normalizedItems.length === 0) {
        const text = message || "No matching foods found.";
        targetElement.innerHTML = `<p class="muted" style="margin: 6px 0;">${text}</p>`;
        return;
      }

      const rankedItems = normalizedItems
        .map((item) => {
          let score = 0;
          if (item.source === "seed") score += 40;
          if (item.source === "usda") score += 20;
          if (item.calories !== null && item.calories !== undefined) score += 12;
          if (item.protein_g !== null && item.protein_g !== undefined) score += 6;
          if (item.serving_size && item.serving_unit) score += 4;
          const name = cleanText(item.display_name || item.name || item.food_name || "");
          if (name) score += 4;
          return { item, score };
        })
        .sort((left, right) => right.score - left.score)
        .slice(0, 15)
        .map((row) => row.item);

      targetElement.innerHTML = "";
      rankedItems.forEach((item) => {
        const button = document.createElement("button");
        button.type = "button";
        button.className = "food-result";
        button.style.display = "block";
        button.style.width = "100%";
        button.style.textAlign = "left";
        button.style.margin = "4px 0";
        button.style.padding = "8px 10px";
        button.style.border = "1px solid #d7dee7";
        button.style.borderRadius = "8px";
        button.style.background = "#fff";
        button.style.cursor = "pointer";

        const title = document.createElement("strong");
        const displayName = cleanText(item.display_name || item.name || item.food_name || item.brand)
          || (item.id ? `Food item #${item.id}` : "Food item");
        title.textContent = displayName;
        button.appendChild(title);

        const meta = document.createElement("div");
        meta.className = "muted";
        meta.style.marginTop = "4px";
        const kcal = item.calories !== null && item.calories !== undefined ? `${item.calories} kcal` : "kcal n/a";
        const serving = item.serving_size && item.serving_unit ? ` | ${item.serving_size} ${item.serving_unit}` : "";
        const source = item.source || "local";
        const protein = item.protein_g !== null && item.protein_g !== undefined ? `P ${displayNumber(Number(item.protein_g), 1)}g` : "P -";
        const carbs = item.carbs_g !== null && item.carbs_g !== undefined ? `C ${displayNumber(Number(item.carbs_g), 1)}g` : "C -";
        const fat = item.fat_g !== null && item.fat_g !== undefined ? `F ${displayNumber(Number(item.fat_g), 1)}g` : "F -";
        meta.textContent = `${kcal}${serving} | ${protein} ${carbs} ${fat} | ${source}`;
        button.appendChild(meta);

        button.addEventListener("click", () => onPick(item));
        targetElement.appendChild(button);
      });
    }

    function renderFoodResults(items, message = "") {
      renderSearchButtons(
        foodResults,
        items,
        (item) => {
          applyFoodOrFavorite(item);
          if (foodResults) foodResults.innerHTML = "";
        },
        message
      );
    }

    function renderBuilderFoodResults(items, message = "") {
      renderSearchButtons(
        builderFoodResults,
        items,
        (item) => {
          addIngredientFromFood(item);
          if (builderFoodResults) builderFoodResults.innerHTML = "";
          if (builderFoodSearchInput) builderFoodSearchInput.value = "";
          setBuilderOpen(true);
        },
        message
      );
    }

    async function fetchFoods(query, remote = false) {
      const params = new URLSearchParams({ q: query });
      if (remote) params.set("remote", "1");
      const response = await fetch(`/foods/search?${params.toString()}`);
      return response.json();
    }

    async function runFoodSearch(remote = false) {
      const query = (foodSearchInput.value || "").trim();
      if (query.length < 2) {
        foodResults.innerHTML = "";
        return;
      }

      const token = ++lastSearchToken;
      try {
        const data = await fetchFoods(query, remote);
        if (token !== lastSearchToken) return;
        renderFoodResults(data.results || [], data.message || "");
      } catch (error) {
        if (token !== lastSearchToken) return;
        foodResults.innerHTML = '<p class="muted" style="margin: 6px 0;">Search failed. Try again.</p>';
      }
    }

    async function runBuilderFoodSearch(remote = false) {
      setEntryMode("recipe");
      setBuilderSource("catalog");
      const query = (builderFoodSearchInput?.value || "").trim();
      if (query.length < 2) {
        if (builderFoodResults) builderFoodResults.innerHTML = "";
        return;
      }

      const token = ++lastBuilderSearchToken;
      try {
        const data = await fetchFoods(query, remote);
        if (token !== lastBuilderSearchToken) return;
        renderBuilderFoodResults(data.results || [], data.message || "");
      } catch (error) {
        if (token !== lastBuilderSearchToken) return;
        if (builderFoodResults) {
          builderFoodResults.innerHTML = '<p class="muted" style="margin: 6px 0;">Ingredient search failed. Try again.</p>';
        }
      }
    }

    if (foodSearchInput) {
      foodSearchInput.addEventListener("input", () => {
        foodItemIdInput.value = "";
        clearTimeout(debounceTimer);
        debounceTimer = setTimeout(() => runFoodSearch(false), 220);
      });
    }

    if (builderFoodSearchInput) {
      builderFoodSearchInput.addEventListener("input", () => {
        clearTimeout(builderDebounceTimer);
        builderDebounceTimer = setTimeout(() => runBuilderFoodSearch(false), 220);
      });
    }

    if (searchUsdaButton) {
      searchUsdaButton.addEventListener("click", () => {
        runFoodSearch(true);
      });
    }

    if (builderSearchUsdaButton) {
      builderSearchUsdaButton.addEventListener("click", () => {
        runBuilderFoodSearch(true);
      });
    }

    if (entryModeSingleButton) {
      entryModeSingleButton.addEventListener("click", () => {
        setEntryMode("single");
      });
    }

    if (entryModeRecipeButton) {
      entryModeRecipeButton.addEventListener("click", () => {
        setEntryMode("recipe");
      });
    }

    if (builderSourceCatalogButton) {
      builderSourceCatalogButton.addEventListener("click", () => {
        setBuilderSource("catalog");
      });
    }

    if (builderSourceProductButton) {
      builderSourceProductButton.addEventListener("click", () => {
        setBuilderSource("product");
      });
    }

    if (builderSourceLabelButton) {
      builderSourceLabelButton.addEventListener("click", () => {
        setBuilderSource("label");
      });
    }

    if (builderSourceManualButton) {
      builderSourceManualButton.addEventListener("click", () => {
        setBuilderSource("manual");
      });
    }

    if (builderToggle) {
      builderToggle.addEventListener("click", () => {
        const open = mealBuilderPanel && mealBuilderPanel.style.display !== "none";
        setBuilderOpen(!open);
      });
    }

    if (builderIngredientsBody) {
      builderIngredientsBody.addEventListener("change", (event) => {
        const target = event.target;
        const rowId = target?.dataset?.rowId;
        const field = target?.dataset?.field;
        if (!rowId || !field) return;

        const row = builderState.ingredients.find((item) => item.row_id === rowId);
        if (!row) return;

        if (field === "quantity") {
          const quantity = Number(target.value);
          row.quantity = Number.isFinite(quantity) && quantity > 0 ? quantity : 0;
        } else if (field === "unit") {
          row.unit = target.value || "serving";
        }
        renderBuilderIngredients();
      });

      builderIngredientsBody.addEventListener("click", (event) => {
        const target = event.target;
        const rowId = target?.dataset?.rowId;
        const action = target?.dataset?.action;
        if (!rowId || !action) return;

        if (action === "edit") {
          const row = builderState.ingredients.find((item) => item.row_id === rowId);
          if (!row) return;
          setCustomIngredientEditMode(rowId);
          populateCustomInputsFromIngredientRow(row);
          return;
        }

        if (action === "remove") {
          builderState.ingredients = builderState.ingredients.filter((item) => item.row_id !== rowId);
          if (builderState.editingRowId === rowId) {
            setCustomIngredientEditMode(null);
            clearCustomIngredientInputs();
          }
          renderBuilderIngredients();
        }
      });
    }

    if (builderApplyButton) {
      builderApplyButton.addEventListener("click", () => {
        applyBuilderToMealForm();
      });
    }

    if (builderClearButton) {
      builderClearButton.addEventListener("click", () => {
        builderState.ingredients = [];
        setCustomIngredientEditMode(null);
        clearCustomIngredientInputs();
        renderBuilderIngredients();
      });
    }

    if (addCustomIngredientButton) {
      addCustomIngredientButton.addEventListener("click", () => {
        addCustomIngredientFromInputs();
      });
    }

    if (cancelEditCustomIngredientButton) {
      cancelEditCustomIngredientButton.addEventListener("click", () => {
        setCustomIngredientEditMode(null);
        clearCustomIngredientInputs();
      });
    }

    if (parseLabelButton) {
      parseLabelButton.addEventListener("click", () => {
        parseNutritionLabelPhoto();
      });
    }

    if (parseProductLinkButton) {
      parseProductLinkButton.addEventListener("click", () => {
        parseProductLink();
      });
    }

    if (mealForm) {
      mealForm.addEventListener("keydown", (event) => {
        if (event.key !== "Enter") return;
        const target = event.target;
        if (!target || target.tagName === "TEXTAREA") return;
        const id = target.id || "";

        if (id === "food_search") {
          event.preventDefault();
          runFoodSearch(false);
          return;
        }
        if (id === "builder_food_search") {
          event.preventDefault();
          runBuilderFoodSearch(false);
          return;
        }

        const builderFormIds = new Set([
          "custom_ingredient_name",
          "custom_product_url",
          "custom_quantity",
          "custom_serving_size_value",
          "custom_serving_size_unit",
          "custom_calories",
          "custom_protein_g",
          "custom_carbs_g",
          "custom_fat_g",
          "custom_sugar_g",
          "custom_sodium_mg",
        ]);
        if (builderFormIds.has(id)) {
          event.preventDefault();
          return;
        }
      });
    }

    setCustomIngredientEditMode(null);
    clearCustomIngredientInputs();
    renderBuilderIngredients();
    setBuilderSource("catalog");
    setEntryMode("single");

    if (isEditMode && !foodItemIdInput.value && foodSearchInput && foodSearchInput.value.trim()) {
      setEntryMode("single");
    }
  </script>
{% endblock %}

